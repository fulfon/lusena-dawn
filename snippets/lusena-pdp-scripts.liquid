{% doc %}
  PDP behavior (variant selection, price updates, gallery switching, sticky ATC).
{% enddoc %}

{% javascript %}
  (() => {
    const root = document.querySelector('[data-lusena-product-section]');
    if (!root) return;

    const productJsonEl = root.querySelector('[data-lusena-product-json]');
    const variantIdInput = root.querySelector('[data-lusena-variant-id]');
    const priceEl = root.querySelector('[data-lusena-price]');
    const compareAtEl = root.querySelector('[data-lusena-compare-at]');
    const pricePerNightEl = root.querySelector('[data-lusena-price-per-night]');
    const stickyBar = root.querySelector('[data-lusena-sticky-atc]');
    const stickyPrices = Array.from(root.querySelectorAll('[data-lusena-sticky-price]'));
    const stickyPricePerNights = Array.from(root.querySelectorAll('[data-lusena-sticky-price-per-night]'));
    const stickyVariants = Array.from(root.querySelectorAll('[data-lusena-sticky-variant]'));
    const stickyImages = Array.from(root.querySelectorAll('[data-lusena-sticky-image]'));
    const stockText = root.querySelector('[data-lusena-stock-text]');
    const stockDot = root.querySelector('[data-lusena-stock-dot]');
    const atcButton = root.querySelector('[data-lusena-atc]');
    const buyNowButton = root.querySelector('[data-lusena-buy-now]');
    const stickyAtcButtons = Array.from(root.querySelectorAll('[data-lusena-sticky-atc-button]'));
    const returnsLinks = Array.from(root.querySelectorAll('[data-lusena-open-returns]'));
    const accordionRoots = Array.from(document.querySelectorAll('[data-lusena-accordion-root]'));
    const specDefinitionToggles = Array.from(document.querySelectorAll('[data-lusena-spec-def-toggle]'));

    const accordionContentObservers = new WeakMap();

    const pricePerNightPrefix = pricePerNightEl?.dataset?.prefix ?? '';
    const pricePerNightSuffix = pricePerNightEl?.dataset?.suffix ?? '';
    const stickyPricePerNightPrefix = stickyPricePerNights[0]?.dataset?.prefix ?? pricePerNightPrefix;
    const stickyPricePerNightSuffix = stickyPricePerNights[0]?.dataset?.suffix ?? pricePerNightSuffix;

    let product;
    try {
      product = JSON.parse(productJsonEl.textContent);
    } catch (e) {
      return;
    }

    const galleryRoot = root.querySelector('[data-lusena-gallery]');
    const stage = root.querySelector('[data-lusena-media-stage]');
    const stageAction = root.querySelector('[data-lusena-stage-action]');
    const stageImg = root.querySelector('[data-lusena-media-stage] img');
    const stageProof = root.querySelector('[data-lusena-stage-proof]');
    const stageBadge = root.querySelector('[data-lusena-stage-bestseller]');
    const stageSizes = stageImg?.getAttribute('sizes') || '';
    const proofId = galleryRoot?.dataset?.lusenaProofId ? String(galleryRoot.dataset.lusenaProofId) : null;
    const isBestseller = !!stageBadge || root.querySelectorAll('[data-lusena-mobile-bestseller]').length > 0;
    const lightboxRoot = root.querySelector('[data-lusena-lightbox]');
    const lightboxViewport = root.querySelector('[data-lusena-lightbox-viewport]');
    const lightboxCounter = root.querySelector('[data-lusena-lightbox-counter]');
    const lightboxCloseButton = root.querySelector('[data-lusena-lightbox-close]');
    const lightboxPrevButton = root.querySelector('[data-lusena-lightbox-prev]');
    const lightboxNextButton = root.querySelector('[data-lusena-lightbox-next]');
    const lightboxImageWrap = root.querySelector('[data-lusena-lightbox-image-wrap]');
    const lightboxImage = root.querySelector('[data-lusena-lightbox-image]');
    const lightboxFallback = root.querySelector('[data-lusena-lightbox-fallback]');
    const lightboxHintDesktop = root.querySelector('[data-lusena-lightbox-hint-desktop]');
    const lightboxHintMobile = root.querySelector('[data-lusena-lightbox-hint-mobile]');

    if (lightboxRoot && lightboxRoot.parentElement !== document.body) {
      document.body.appendChild(lightboxRoot);
    }

    const desktopThumbsWrap = root.querySelector('[data-lusena-media-thumbs-desktop]');
    const thumbEls = desktopThumbsWrap ? Array.from(desktopThumbsWrap.querySelectorAll('[data-lusena-thumb]')) : [];
    const thumbsById = new Map(
      thumbEls
        .map((el) => {
          const id = el?.dataset?.mediaId;
          return id ? [String(id), el] : null;
        })
        .filter(Boolean)
    );

    const mobileTrack = root.querySelector('[data-lusena-mobile-track]');
    const mobileSlideEls = mobileTrack ? Array.from(mobileTrack.querySelectorAll('[data-lusena-mobile-slide]')) : [];
    const slidesById = new Map(
      mobileSlideEls
        .map((el) => {
          const id = el?.dataset?.mediaId;
          return id ? [String(id), el] : null;
        })
        .filter(Boolean)
    );

    const mobileDotsWrap = root.querySelector('[data-lusena-mobile-dots]');
    const mobileDotEls = mobileDotsWrap ? Array.from(mobileDotsWrap.querySelectorAll('[data-lusena-mobile-dot]')) : [];
    const dotsById = new Map(
      mobileDotEls
        .map((el) => {
          const id = el?.dataset?.mediaId;
          return id ? [String(id), el] : null;
        })
        .filter(Boolean)
    );

    const normalizeImageUrl = (src) => {
      if (!src) return null;
      if (src.startsWith('//')) return `https:${src}`;
      return src;
    };

    const urlWithWidth = (src, width) => {
      const normalized = normalizeImageUrl(src);
      if (!normalized) return null;
      try {
        const u = new URL(normalized);
        u.searchParams.set('width', String(width));
        return u.toString();
      } catch (e) {
        return normalized;
      }
    };

    const setResponsiveImage = ({ img, src, widths, sizes, alt }) => {
      if (!img || !src) return;
      const normalized = normalizeImageUrl(src);
      if (!normalized) return;

      const maxWidth = widths[widths.length - 1];
      const srcWithWidth = urlWithWidth(normalized, maxWidth);
      const srcset = widths
        .map((w) => {
          const u = urlWithWidth(normalized, w);
          return u ? `${u} ${w}w` : null;
        })
        .filter(Boolean)
        .join(', ');

      if (srcWithWidth) img.src = srcWithWidth;
      if (srcset) img.setAttribute('srcset', srcset);
      if (sizes) img.setAttribute('sizes', sizes);
      if (typeof alt === 'string') img.alt = alt;
    };

    const findMediaById = (mediaId) => {
      if (!mediaId) return null;
      const idString = String(mediaId);
      return product?.media?.find((m) => String(m?.id) === idString) || null;
    };

    const normalizeKey = (value) => (typeof value === 'string' ? value.trim().toLowerCase() : '');

    const parseAlt = (alt) => {
      const raw = typeof alt === 'string' ? alt : '';
      const parts = raw.split('|').map((p) => p.trim()).filter(Boolean);

      const cleanAltCandidate = parts.length ? parts[0] : '';
      const cleanAltLooksLikeTag = /^\[(shared|color\s*=)/i.test(cleanAltCandidate);
      const cleanAlt = parts.length > 1 ? cleanAltCandidate : cleanAltLooksLikeTag ? '' : cleanAltCandidate;

      const tagText = parts.length > 1 ? parts[parts.length - 1] : raw;
      const shared = /\[shared\]/i.test(tagText);
      const colorMatch = tagText.match(/\[color\s*=\s*([^\]]+)\]/i);
      const colorTag = colorMatch ? colorMatch[1].trim() : null;

      return { cleanAlt, shared, colorTag };
    };

    const getMediaAltRaw = (media) => media?.alt || media?.preview_image?.alt || '';

    const hasAnyTagging = () =>
      Array.isArray(product?.media) && product.media.some((m) => /\[(shared|color\s*=)/i.test(getMediaAltRaw(m)));

    const taggingEnabled = hasAnyTagging();

    const getColorOptionIndex = () => {
      const fieldset = root.querySelector('[data-lusena-option-type="color"]');
      if (!fieldset) return null;
      const idx = Number(fieldset.dataset.optionIndex);
      return Number.isFinite(idx) ? idx : null;
    };

    const getSelectedColorForVariant = (variant) => {
      const colorIndex = getColorOptionIndex();
      if (colorIndex === null) return null;
      const options = variant?.options;
      if (!Array.isArray(options)) return null;
      return options[colorIndex] || null;
    };

    const getStickyVariantLabel = (variant) => {
      const selectedColor = getSelectedColorForVariant(variant);
      if (selectedColor) return selectedColor;
      if (Array.isArray(variant?.options) && variant.options.length) return variant.options[0] || variant?.title || '';
      return variant?.title || '';
    };

    const getVariantImageSrc = (variant) => {
      if (!variant) return null;

      if (variant?.featured_image && typeof variant.featured_image === 'object' && variant.featured_image.src) {
        return variant.featured_image.src;
      }

      const featuredMediaId =
        variant?.featured_media && typeof variant.featured_media === 'object' ? variant.featured_media.id : variant?.featured_media;
      if (featuredMediaId) {
        const featuredMedia = findMediaById(featuredMediaId);
        if (featuredMedia) return featuredMedia?.preview_image?.src || featuredMedia?.src || null;
      }

      return product?.featured_image?.src || product?.featured_media?.preview_image?.src || null;
    };

    const getVisibleMediaForColor = (color) => {
      const media = Array.isArray(product?.media) ? product.media : [];
      if (!media.length) return { colorMedia: [], sharedMedia: [], visible: [], taggingEnabled: false };

      if (!taggingEnabled || !color) {
        return { colorMedia: [], sharedMedia: [], visible: media, taggingEnabled };
      }

      const normalizedColor = normalizeKey(color);
      const colorMedia = [];
      const sharedMedia = [];

      media.forEach((m) => {
        const { shared, colorTag } = parseAlt(getMediaAltRaw(m));
        const isSharedEffective = shared || (!colorTag && taggingEnabled);

        if (colorTag && normalizeKey(colorTag) === normalizedColor) colorMedia.push(m);
        else if (isSharedEffective) sharedMedia.push(m);
      });

      const visible = colorMedia.length ? [...colorMedia, ...sharedMedia] : sharedMedia.length ? sharedMedia : media;
      return { colorMedia, sharedMedia, visible, taggingEnabled };
    };

    const state = {
      activeIndex: 0,
      colorMediaLength: 0,
      activeKind: 'color',
      initialized: false,
      visibleItems: [],
    };

    const LIGHTBOX_HASH = '#lightbox';
    const LIGHTBOX_DESKTOP_MAX_ZOOM = 1.5;
    const LIGHTBOX_MOBILE_MAX_ZOOM = 2.5;
    const LIGHTBOX_MIN_ZOOM = 1;

    const lightboxState = {
      open: false,
      slides: [],
      index: 0,
      openedAt: 0,
      zoom: 1,
      translate: { x: 0, y: 0 },
      imageLoaded: false,
      imageError: false,
      pinch: null,
      pan: null,
      lastTapAt: 0,
      touchStart: null,
      scrollY: 0,
    };

    const isMediaZoomable = (media) => media?.media_type === 'image';

    const buildVisibleItems = (visibleMedia) => {
      const items = visibleMedia.map((media) => ({
        id: String(media?.id),
        type: 'media',
        media,
      }));

      if (proofId) {
        items.push({
          id: proofId,
          type: 'proof',
        });
      }

      return items;
    };

    const setActiveThumb = (activeItemId) => {
      thumbEls.forEach((el) => el.removeAttribute('aria-current'));
      if (!activeItemId) return;
      const el = thumbsById.get(String(activeItemId));
      if (el) el.setAttribute('aria-current', 'true');
    };

    const setActiveDot = (activeItemId) => {
      mobileDotEls.forEach((el) => el.removeAttribute('aria-current'));
      if (!activeItemId) return;
      const el = dotsById.get(String(activeItemId));
      if (el && !el.hidden) el.setAttribute('aria-current', 'true');
    };

    const setDesktopBestseller = (isVisible) => {
      if (!stageBadge) return;
      stageBadge.hidden = !isVisible;
    };

    const setMobileBestseller = (visibleItems) => {
      root.querySelectorAll('[data-lusena-mobile-bestseller]').forEach((badge) => {
        badge.hidden = true;
      });

      if (!isBestseller || !visibleItems.length) return;
      const firstSlide = slidesById.get(visibleItems[0].id);
      const firstBadge = firstSlide?.querySelector('[data-lusena-mobile-bestseller]');
      if (firstBadge) firstBadge.hidden = false;
    };

    const applyDesktopThumbOrderAndVisibility = (visibleItems) => {
      if (!desktopThumbsWrap) return;
      const visibleIds = new Set(visibleItems.map((item) => item.id));

      thumbEls.forEach((el) => {
        const id = String(el?.dataset?.mediaId || '');
        el.hidden = !visibleIds.has(id);
      });

      visibleItems.forEach((item) => {
        const el = thumbsById.get(item.id);
        if (el) desktopThumbsWrap.appendChild(el);
      });
    };

    const applyMobileOrderAndVisibility = (visibleItems) => {
      if (!mobileTrack) return;
      const visibleIds = new Set(visibleItems.map((item) => item.id));

      mobileSlideEls.forEach((slide) => {
        const id = String(slide?.dataset?.mediaId || '');
        slide.hidden = !visibleIds.has(id);
      });

      visibleItems.forEach((item) => {
        const slide = slidesById.get(item.id);
        if (slide) mobileTrack.appendChild(slide);
      });

      mobileDotEls.forEach((dot) => {
        const id = String(dot?.dataset?.mediaId || '');
        dot.hidden = !visibleIds.has(id);
      });

      visibleItems.forEach((item) => {
        const dot = dotsById.get(item.id);
        if (dot && mobileDotsWrap) mobileDotsWrap.appendChild(dot);
      });

      if (mobileDotsWrap) {
        mobileDotsWrap.hidden = visibleItems.length <= 1;
      }
    };

    const applyGalleryOrderAndVisibility = (visibleItems) => {
      applyDesktopThumbOrderAndVisibility(visibleItems);
      applyMobileOrderAndVisibility(visibleItems);
      setMobileBestseller(visibleItems);
      state.visibleItems = visibleItems;
    };

    const setStageByMedia = (media) => {
      if (!stageImg || !media) return;
      const src = media?.preview_image?.src || media?.src;
      if (!src) return;

      const { cleanAlt } = parseAlt(getMediaAltRaw(media));
      stageImg.style.opacity = '0';
      requestAnimationFrame(() => {
        setResponsiveImage({
          img: stageImg,
          src,
          widths: [600, 800, 1200, 1600],
          sizes: stageSizes,
          alt: cleanAlt,
        });
        stageImg.style.opacity = '1';
      });
    };

    const setStageByItem = (item) => {
      if (!stage || !item) return;

      const setStageActionState = (isZoomable) => {
        if (!stageAction) return;
        stageAction.dataset.lusenaStageZoomable = isZoomable ? 'true' : 'false';
        if (isZoomable) {
          stageAction.setAttribute('role', 'button');
          stageAction.setAttribute('tabindex', '0');
          stageAction.setAttribute('aria-label', 'Powieksz zdjecie produktu');
        } else {
          stageAction.removeAttribute('role');
          stageAction.removeAttribute('tabindex');
          stageAction.removeAttribute('aria-label');
        }
      };

      if (item.type === 'proof') {
        stage.dataset.stageType = 'proof';
        if (stageProof) stageProof.hidden = false;
        setStageActionState(false);
        return;
      }

      stage.dataset.stageType = 'image';
      if (stageProof) stageProof.hidden = true;
      setStageActionState(isMediaZoomable(item.media));
      setStageByMedia(item.media);
    };

    const scrollMobileToItem = (itemId, behavior = 'smooth') => {
      if (!mobileTrack || !itemId) return;
      const slide = slidesById.get(String(itemId));
      if (!slide || slide.hidden) return;
      mobileTrack.scrollTo({ left: slide.offsetLeft, behavior });
    };

    const selectMediaIndex = (index, visibleItems, options = {}) => {
      if (!visibleItems.length) return;
      const safeIndex = Math.max(0, Math.min(index, visibleItems.length - 1));
      const item = visibleItems[safeIndex];
      state.activeIndex = safeIndex;

      if (item.type === 'proof') {
        state.activeKind = 'proof';
      } else if (!taggingEnabled) {
        state.activeKind = 'color';
      } else if (state.colorMediaLength > 0 && safeIndex < state.colorMediaLength) {
        state.activeKind = 'color';
      } else {
        state.activeKind = 'shared';
      }

      setStageByItem(item);
      setActiveThumb(item.id);
      setActiveDot(item.id);
      setDesktopBestseller(isBestseller && safeIndex === 0);

      if (options.scrollMobile !== false) {
        scrollMobileToItem(item.id, options.instant ? 'auto' : 'smooth');
      }
    };

    const isTouchDevice = () => window.matchMedia('(pointer: coarse)').matches;

    const getLightboxMaxZoom = () => (isTouchDevice() ? LIGHTBOX_MOBILE_MAX_ZOOM : LIGHTBOX_DESKTOP_MAX_ZOOM);

    const getLightboxSlides = () =>
      state.visibleItems
        .filter((item) => item.type === 'media' && isMediaZoomable(item.media))
        .map((item) => {
          const media = item.media;
          const src = media?.src || media?.preview_image?.src;
          const { cleanAlt } = parseAlt(getMediaAltRaw(media));
          const width = Number(media?.preview_image?.width || media?.width || 0);
          const height = Number(media?.preview_image?.height || media?.height || 0);
          return {
            id: item.id,
            src: normalizeImageUrl(src),
            alt: cleanAlt || product?.title || '',
            width,
            height,
          };
        })
        .filter((slide) => !!slide.src);

    const updateLightboxHintText = () => {
      const isZoomed = lightboxState.zoom > 1;
      if (lightboxHintDesktop) {
        lightboxHintDesktop.textContent = isZoomed ? 'Kliknij aby oddalic' : 'Kliknij aby powiekszyc';
      }
      if (lightboxHintMobile) {
        lightboxHintMobile.textContent = isZoomed
          ? 'Dotknij dwukrotnie aby oddalic'
          : 'Dotknij dwukrotnie lub rozsun palce';
      }
    };

    const getLightboxMaxTranslate = (zoomValue) => {
      if (!lightboxViewport || zoomValue <= 1) return { x: 0, y: 0 };
      const baseRect = getLightboxInteractionRect();
      if (!baseRect) return { x: 0, y: 0 };
      return {
        x: Math.max(0, (zoomValue * baseRect.width - lightboxViewport.clientWidth) / (2 * zoomValue)),
        y: Math.max(0, (zoomValue * baseRect.height - lightboxViewport.clientHeight) / (2 * zoomValue)),
      };
    };

    const clampLightboxTranslate = (tx, ty, zoomValue) => {
      const max = getLightboxMaxTranslate(zoomValue);
      return {
        x: Math.max(-max.x, Math.min(max.x, tx)),
        y: Math.max(-max.y, Math.min(max.y, ty)),
      };
    };

    const applyLightboxTransform = () => {
      if (!lightboxImage) return;
      lightboxImage.style.transform = `scale(${lightboxState.zoom}) translate(${lightboxState.translate.x}px, ${lightboxState.translate.y}px)`;
      lightboxImage.classList.toggle('is-zoomed', lightboxState.zoom > 1);
      if (lightboxRoot) lightboxRoot.classList.toggle('is-zoomed', lightboxState.zoom > 1);
      updateLightboxHintText();
    };

    const resetLightboxZoom = () => {
      lightboxState.zoom = LIGHTBOX_MIN_ZOOM;
      lightboxState.translate = { x: 0, y: 0 };
      applyLightboxTransform();
    };

    const syncLightboxNav = () => {
      if (!lightboxPrevButton || !lightboxNextButton) return;
      lightboxPrevButton.disabled = lightboxState.index <= 0;
      lightboxNextButton.disabled = lightboxState.index >= lightboxState.slides.length - 1;
    };

    const setLightboxCounter = () => {
      if (!lightboxCounter) return;
      if (lightboxState.slides.length > 1) {
        lightboxCounter.textContent = `${lightboxState.index + 1} / ${lightboxState.slides.length}`;
      } else {
        lightboxCounter.textContent = '';
      }
    };

    const renderLightboxError = (message) => {
      if (!lightboxImageWrap) return;
      lightboxState.imageError = true;
      lightboxState.imageLoaded = false;
      lightboxImageWrap.classList.add('is-error');
      lightboxImageWrap.classList.remove('is-loaded');
      if (lightboxFallback) {
        lightboxFallback.textContent = message;
        lightboxFallback.hidden = false;
      }
    };

    const renderLightboxSlide = ({ resetZoom = false } = {}) => {
      if (!lightboxImageWrap || !lightboxImage) return;
      const slide = lightboxState.slides[lightboxState.index];
      lightboxState.imageLoaded = false;
      lightboxState.imageError = false;
      lightboxImageWrap.classList.remove('is-loaded', 'is-error');
      if (lightboxFallback) lightboxFallback.hidden = true;

      if (resetZoom) resetLightboxZoom();
      setLightboxCounter();
      syncLightboxNav();

      if (!slide?.src) {
        renderLightboxError('Brak zdjecia');
        return;
      }

      if (Number.isFinite(slide.width) && Number.isFinite(slide.height) && slide.width > 0 && slide.height > 0) {
        lightboxImage.setAttribute('width', String(slide.width));
        lightboxImage.setAttribute('height', String(slide.height));
      }

      lightboxImage.src = slide.src;
      lightboxImage.alt = slide.alt || '';
    };

    const lockBodyForLightbox = () => {
      lightboxState.scrollY = window.scrollY;
      document.body.style.position = 'fixed';
      document.body.style.top = `-${lightboxState.scrollY}px`;
      document.body.style.width = '100%';
      document.body.style.overflow = 'hidden';
    };

    const unlockBodyForLightbox = () => {
      document.body.style.position = '';
      document.body.style.top = '';
      document.body.style.width = '';
      document.body.style.overflow = '';
      window.scrollTo(0, lightboxState.scrollY || 0);
    };

    const closeLightbox = (fromPopstate = false) => {
      if (!lightboxState.open || !lightboxRoot) return;
      lightboxState.open = false;
      lightboxState.openedAt = 0;
      lightboxRoot.classList.remove('is-visible', 'is-zoomed', 'is-over-image');
      window.setTimeout(() => {
        if (!lightboxState.open) lightboxRoot.hidden = true;
      }, 200);

      unlockBodyForLightbox();

      if (!fromPopstate && location.hash === LIGHTBOX_HASH) {
        history.replaceState(null, '', `${location.pathname}${location.search}`);
      }
    };

    const navigateLightbox = (direction) => {
      if (!lightboxState.open) return;
      const nextIndex = lightboxState.index + direction;
      if (nextIndex < 0 || nextIndex >= lightboxState.slides.length) return;
      lightboxState.index = nextIndex;
      renderLightboxSlide({ resetZoom: true });
    };

    const openLightboxByItemId = (itemId) => {
      if (!lightboxRoot || !itemId) return;
      const slides = getLightboxSlides();
      if (!slides.length) return;

      const nextIndex = slides.findIndex((slide) => slide.id === String(itemId));
      if (nextIndex < 0) return;

      lightboxState.slides = slides;
      lightboxState.index = nextIndex;
      lightboxState.open = true;
      lightboxState.openedAt = Date.now();
      lightboxRoot.hidden = false;
      setLightboxHoverState(false);
      lockBodyForLightbox();
      renderLightboxSlide({ resetZoom: true });
      requestAnimationFrame(() => {
        lightboxRoot.classList.add('is-visible');
      });

      if (location.hash !== LIGHTBOX_HASH) {
        history.pushState(null, '', `${location.pathname}${location.search}${LIGHTBOX_HASH}`);
      }

      window.setTimeout(() => {
        lightboxCloseButton?.focus();
      }, 80);
    };

    const refreshLightboxSlides = () => {
      if (!lightboxState.open) return;
      const activeSlideId = lightboxState.slides[lightboxState.index]?.id || null;
      const refreshedSlides = getLightboxSlides();
      if (!refreshedSlides.length) {
        closeLightbox();
        return;
      }

      lightboxState.slides = refreshedSlides;
      const remappedIndex = activeSlideId ? refreshedSlides.findIndex((slide) => slide.id === activeSlideId) : -1;
      if (remappedIndex >= 0) {
        lightboxState.index = remappedIndex;
      } else if (lightboxState.index > refreshedSlides.length - 1) {
        lightboxState.index = refreshedSlides.length - 1;
      }
      renderLightboxSlide({ resetZoom: true });
    };

    const getTouchDistance = (touches) => {
      if (!touches || touches.length < 2) return 0;
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    };

    const setLightboxHoverState = (isOverImage) => {
      if (!lightboxRoot) return;
      lightboxRoot.classList.toggle('is-over-image', !!isOverImage);
    };

    const getLightboxInteractionRect = () => {
      if (!lightboxImage || !lightboxViewport || !lightboxState.imageLoaded || lightboxState.imageError) return null;

      const viewportRect = lightboxViewport.getBoundingClientRect();
      if (viewportRect.width <= 0 || viewportRect.height <= 0) return null;

      const intrinsicWidth = Number(lightboxImage.naturalWidth || lightboxImage.getAttribute('width') || 0);
      const intrinsicHeight = Number(lightboxImage.naturalHeight || lightboxImage.getAttribute('height') || 0);

      const maxRenderWidth = Math.min(viewportRect.width, window.innerWidth * 0.9);
      const maxRenderHeight = Math.min(viewportRect.height, window.innerHeight * 0.85);

      let renderWidth = maxRenderWidth;
      let renderHeight = maxRenderHeight;

      if (intrinsicWidth > 0 && intrinsicHeight > 0) {
        const scale = Math.min(maxRenderWidth / intrinsicWidth, maxRenderHeight / intrinsicHeight, 1);
        renderWidth = intrinsicWidth * scale;
        renderHeight = intrinsicHeight * scale;
      }

      const left = viewportRect.left + (viewportRect.width - renderWidth) / 2;
      const top = viewportRect.top + (viewportRect.height - renderHeight) / 2;
      return {
        left,
        top,
        right: left + renderWidth,
        bottom: top + renderHeight,
        width: renderWidth,
        height: renderHeight,
      };
    };

    const isPointInsideLightboxImage = (clientX, clientY) => {
      const rect = getLightboxInteractionRect();
      if (!rect) return false;
      const edgeTolerance = 2;
      return (
        clientX >= rect.left - edgeTolerance &&
        clientX <= rect.right + edgeTolerance &&
        clientY >= rect.top - edgeTolerance &&
        clientY <= rect.bottom + edgeTolerance
      );
    };

    const handleDesktopLightboxImageClick = (event) => {
      if (!lightboxState.open) return;
      if (Date.now() - lightboxState.openedAt < 220) return;

      if (lightboxState.zoom > 1) {
        resetLightboxZoom();
        return;
      }

      const zoomLevel = getLightboxMaxZoom();
      const rect = getLightboxInteractionRect();
      if (!rect || rect.width <= 0 || rect.height <= 0) return;
      const clickX = (event.clientX - rect.left) / rect.width;
      const clickY = (event.clientY - rect.top) / rect.height;
      const max = getLightboxMaxTranslate(zoomLevel);
      lightboxState.zoom = zoomLevel;
      lightboxState.translate = clampLightboxTranslate((0.5 - clickX) * 2 * max.x, (0.5 - clickY) * 2 * max.y, zoomLevel);
      applyLightboxTransform();
    };

    if (lightboxRoot) {
      lightboxRoot.addEventListener('click', (event) => {
        if (!lightboxState.open) return;
        const onTouchDevice = isTouchDevice();

        const target =
          event.target instanceof Element
            ? event.target
            : event.target && event.target.parentElement instanceof Element
              ? event.target.parentElement
              : null;
        if (!target) {
          closeLightbox();
          return;
        }

        if (target.closest('[data-lusena-lightbox-close], [data-lusena-lightbox-prev], [data-lusena-lightbox-next]')) {
          return;
        }

        if (target.closest('.lusena-lightbox__top, .lusena-lightbox__bottom')) {
          closeLightbox();
          return;
        }

        const clickedInsideImage = isPointInsideLightboxImage(event.clientX, event.clientY);

        if (onTouchDevice) {
          if (lightboxState.zoom <= 1 && !clickedInsideImage) {
            closeLightbox();
          }
          return;
        }

        if (clickedInsideImage) {
          handleDesktopLightboxImageClick(event);
          return;
        }

        closeLightbox();
      });
    }

    const handleLightboxPopState = () => {
      if (lightboxState.open) closeLightbox(true);
    };

    const handleLightboxKeydown = (event) => {
      if (!lightboxState.open) return;

      if (event.key === 'Escape') {
        event.preventDefault();
        closeLightbox();
        return;
      }

      if (event.key === 'ArrowLeft') {
        event.preventDefault();
        navigateLightbox(-1);
        return;
      }

      if (event.key === 'ArrowRight') {
        event.preventDefault();
        navigateLightbox(1);
        return;
      }

      if (event.key === 'Tab' && lightboxRoot) {
        const focusable = Array.from(
          lightboxRoot.querySelectorAll('button:not([disabled]):not([hidden]), [tabindex]:not([tabindex="-1"])')
        );
        if (!focusable.length) return;

        const first = focusable[0];
        const last = focusable[focusable.length - 1];

        if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        } else if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        }
      }
    };

    if (lightboxImage) {
      lightboxImage.addEventListener('load', () => {
        if (!lightboxState.open || !lightboxImageWrap) return;
        lightboxState.imageLoaded = true;
        lightboxState.imageError = false;
        lightboxImageWrap.classList.add('is-loaded');
        lightboxImageWrap.classList.remove('is-error');
      });

      lightboxImage.addEventListener('error', () => {
        if (!lightboxState.open) return;
        renderLightboxError('Nie udalo sie zaladowac zdjecia');
      });
    }

    if (lightboxViewport) {
      lightboxViewport.addEventListener('mousemove', (event) => {
        if (!lightboxState.open || isTouchDevice()) return;
        const insideImage = isPointInsideLightboxImage(event.clientX, event.clientY);
        setLightboxHoverState(insideImage);
        if (lightboxState.zoom <= 1 || !insideImage) return;
        const rect = getLightboxInteractionRect();
        if (!rect || rect.width <= 0 || rect.height <= 0) return;
        const x = Math.max(0, Math.min(1, (event.clientX - rect.left) / rect.width));
        const y = Math.max(0, Math.min(1, (event.clientY - rect.top) / rect.height));
        const max = getLightboxMaxTranslate(lightboxState.zoom);
        lightboxState.translate = {
          x: (0.5 - x) * 2 * max.x,
          y: (0.5 - y) * 2 * max.y,
        };
        applyLightboxTransform();
      });

      lightboxViewport.addEventListener('mouseleave', () => {
        setLightboxHoverState(false);
      });

      lightboxViewport.addEventListener(
        'touchstart',
        (event) => {
          if (!lightboxState.open) return;
          if (event.touches.length === 2) {
            lightboxState.pinch = {
              startDist: getTouchDistance(event.touches),
              startZoom: lightboxState.zoom,
            };
            return;
          }

          if (event.touches.length === 1) {
            const touch = event.touches[0];
            const now = Date.now();
            lightboxState.touchStart = { x: touch.clientX, y: touch.clientY, time: now };
            if (lightboxState.zoom > 1) {
              lightboxState.pan = {
                startX: touch.clientX,
                startY: touch.clientY,
                startTx: lightboxState.translate.x,
                startTy: lightboxState.translate.y,
              };
            }
          }
        },
        { passive: true }
      );

      lightboxViewport.addEventListener(
        'touchmove',
        (event) => {
          if (!lightboxState.open) return;
          if (event.touches.length === 2 && lightboxState.pinch) {
            const nextDistance = getTouchDistance(event.touches);
            const scaled = Math.min(
              Math.max((nextDistance / lightboxState.pinch.startDist) * lightboxState.pinch.startZoom, LIGHTBOX_MIN_ZOOM),
              LIGHTBOX_MOBILE_MAX_ZOOM
            );
            lightboxState.zoom = scaled;
            const midX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
            const midY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
            const rect = getLightboxInteractionRect() || lightboxViewport.getBoundingClientRect();
            const relX = (midX - rect.left) / rect.width;
            const relY = (midY - rect.top) / rect.height;
            const max = getLightboxMaxTranslate(scaled);
            lightboxState.translate = clampLightboxTranslate((0.5 - relX) * 2 * max.x, (0.5 - relY) * 2 * max.y, scaled);
            applyLightboxTransform();
            return;
          }

          if (event.touches.length === 1 && lightboxState.zoom > 1 && lightboxState.pan) {
            const touch = event.touches[0];
            const dx = (touch.clientX - lightboxState.pan.startX) / lightboxState.zoom;
            const dy = (touch.clientY - lightboxState.pan.startY) / lightboxState.zoom;
            lightboxState.translate = clampLightboxTranslate(
              lightboxState.pan.startTx + dx,
              lightboxState.pan.startTy + dy,
              lightboxState.zoom
            );
            applyLightboxTransform();
          }
        },
        { passive: true }
      );

      lightboxViewport.addEventListener(
        'touchend',
        (event) => {
          if (!lightboxState.open) return;

          if (lightboxState.pinch && event.touches.length < 2) {
            lightboxState.pinch = null;
            if (lightboxState.zoom < 1.1) resetLightboxZoom();
          }

          if (event.touches.length === 0 && lightboxState.touchStart) {
            const start = lightboxState.touchStart;
            const changedTouch = event.changedTouches[0];
            const now = Date.now();
            const dx = changedTouch.clientX - start.x;
            const dy = changedTouch.clientY - start.y;
            const moved = Math.abs(dx) > 15 || Math.abs(dy) > 15;
            const elapsed = now - start.time;

            if (!moved && elapsed < 300) {
              const sinceLastTap = now - lightboxState.lastTapAt;
              if (sinceLastTap < 350) {
                if (lightboxState.zoom > 1) {
                  resetLightboxZoom();
                } else {
                  const zoomLevel = LIGHTBOX_MOBILE_MAX_ZOOM;
                  const rect = getLightboxInteractionRect() || lightboxViewport.getBoundingClientRect();
                  const relX = (changedTouch.clientX - rect.left) / rect.width;
                  const relY = (changedTouch.clientY - rect.top) / rect.height;
                  const max = getLightboxMaxTranslate(zoomLevel);
                  lightboxState.zoom = zoomLevel;
                  lightboxState.translate = clampLightboxTranslate(
                    (0.5 - relX) * 2 * max.x,
                    (0.5 - relY) * 2 * max.y,
                    zoomLevel
                  );
                  applyLightboxTransform();
                }
                lightboxState.lastTapAt = 0;
              } else {
                lightboxState.lastTapAt = now;
              }
            }

            if (
              lightboxState.zoom <= 1 &&
              Math.abs(dx) > 60 &&
              Math.abs(dx) > Math.abs(dy) &&
              elapsed < 400
            ) {
              navigateLightbox(dx < 0 ? 1 : -1);
            }
          }

          lightboxState.touchStart = null;
          lightboxState.pan = null;
        },
        { passive: true }
      );
    }

    lightboxCloseButton?.addEventListener('click', () => closeLightbox());
    lightboxPrevButton?.addEventListener('click', () => navigateLightbox(-1));
    lightboxNextButton?.addEventListener('click', () => navigateLightbox(1));
    window.addEventListener('popstate', handleLightboxPopState);
    window.addEventListener('keydown', handleLightboxKeydown);

    const updateGalleryForVariant = (variant) => {
      if (!variant) return;
      const color = getSelectedColorForVariant(variant);
      const { visible, colorMedia } = getVisibleMediaForColor(color);
      const visibleItems = buildVisibleItems(visible);
      if (!visibleItems.length) {
        if (lightboxState.open) closeLightbox();
        return;
      }

      const wasOnShared = state.initialized && taggingEnabled && state.activeKind === 'shared';
      const wasOnProof = state.initialized && state.activeKind === 'proof';

      state.colorMediaLength = colorMedia.length;
      applyGalleryOrderAndVisibility(visibleItems);

      const selectAndRefresh = (indexToSelect) => {
        selectMediaIndex(indexToSelect, visibleItems, { scrollMobile: false, instant: true });
        refreshLightboxSlides();
      };

      if (!state.initialized) {
        state.initialized = true;

        const featuredMediaId =
          variant?.featured_media && typeof variant.featured_media === 'object' ? variant.featured_media.id : variant?.featured_media;
        const initialFeaturedIndex = featuredMediaId
          ? visibleItems.findIndex((item) => item.type === 'media' && String(item?.media?.id) === String(featuredMediaId))
          : -1;

        selectAndRefresh(initialFeaturedIndex >= 0 ? initialFeaturedIndex : 0);
        return;
      }

      if (wasOnProof && proofId) {
        const proofIndex = visibleItems.findIndex((item) => item.type === 'proof');
        if (proofIndex >= 0) {
          selectAndRefresh(proofIndex);
          return;
        }
      }

      if (wasOnShared) {
        selectAndRefresh(0);
        return;
      }

      if (colorMedia.length) {
        const nextIndex = Math.min(state.activeIndex, colorMedia.length - 1);
        selectAndRefresh(nextIndex);
        return;
      }

      selectAndRefresh(0);
    };

    const formatCurrency = (cents, { minimumFractionDigits = 0, maximumFractionDigits = 2 } = {}) => {
      try {
        return new Intl.NumberFormat('pl-PL', {
          style: 'currency',
          currency: 'PLN',
          minimumFractionDigits,
          maximumFractionDigits,
        })
          .format(cents / 100)
          .replace(/\u00a0/g, ' ');
      } catch (error) {
        const value = (cents / 100).toFixed(Math.max(minimumFractionDigits, 2)).replace('.', ',');
        return `${value} zÅ‚`;
      }
    };

    const getSelectedOptions = () => {
      const optionFieldsets = root.querySelectorAll('[data-lusena-option]');
      const values = [];
      optionFieldsets.forEach((fieldset) => {
        const input = fieldset.querySelector('input[type="radio"]:checked');
        values.push(input ? input.value : null);
      });
      return values;
    };

    const findVariant = (options) =>
      product?.variants?.find((v) => {
        if (!v?.options) return false;
        return v.options.every((opt, idx) => opt === options[idx]);
      });

    const setSelectedLabel = () => {
      const optionFieldsets = root.querySelectorAll('[data-lusena-option]');
      optionFieldsets.forEach((fieldset) => {
        const selected = fieldset.querySelector('input[type="radio"]:checked')?.value;
        const label = fieldset.querySelector('[data-lusena-selected]');
        if (label && selected) label.textContent = selected;
      });
    };

    const updateUIForVariant = (variant) => {
      if (!variant) return;
      if (variantIdInput) variantIdInput.value = variant.id;

      if (priceEl) priceEl.textContent = formatCurrency(variant.price, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
      stickyPrices.forEach((stickyPrice) => {
        stickyPrice.textContent = formatCurrency(variant.price, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
      });

      const perNightCents = Math.round(variant.price / 365);
      stickyPricePerNights.forEach((stickyPricePerNight) => {
        stickyPricePerNight.textContent = `${stickyPricePerNightPrefix}${formatCurrency(perNightCents, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        })}${stickyPricePerNightSuffix}`;
      });

      const stickyVariantLabel = getStickyVariantLabel(variant);
      stickyVariants.forEach((stickyVariant) => {
        stickyVariant.textContent = stickyVariantLabel;
      });

      const stickyImageSrc = getVariantImageSrc(variant);
      const normalizedStickyImageSrc = normalizeImageUrl(stickyImageSrc);
      if (stickyImages.length) {
        stickyImages.forEach((stickyImage) => {
          if (normalizedStickyImageSrc) {
            stickyImage.src = urlWithWidth(normalizedStickyImageSrc, 88) || normalizedStickyImageSrc;
          }

          if (stickyVariantLabel) stickyImage.alt = stickyVariantLabel;
          else if (product?.title) stickyImage.alt = product.title;
        });
      }

      const compareAt = variant.compare_at_price;
      if (compareAtEl) {
        if (compareAt && compareAt > variant.price) {
          compareAtEl.textContent = formatCurrency(compareAt, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
          compareAtEl.classList.remove('hidden');
        } else {
          compareAtEl.textContent = '';
          compareAtEl.classList.add('hidden');
        }
      }

      if (pricePerNightEl) {
        pricePerNightEl.textContent = `${pricePerNightPrefix}${formatCurrency(perNightCents, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}${pricePerNightSuffix}`;
      }

      const available = !!variant.available;
      if (stockText) {
        const inStock = stockText.dataset.inStock ?? '';
        const outOfStock = stockText.dataset.outOfStock ?? '';
        stockText.textContent = available ? inStock : outOfStock;
      }
      if (stockDot) {
        stockDot.classList.toggle('lusena-pdp__stock-dot--available', available);
        stockDot.classList.toggle('lusena-pdp__stock-dot--unavailable', !available);
      }
      if (atcButton) atcButton.disabled = !available;
      if (buyNowButton) {
        buyNowButton.disabled = !available;
        if (available) buyNowButton.removeAttribute('aria-disabled');
      }
      stickyAtcButtons.forEach((stickyAtcButton) => {
        stickyAtcButton.disabled = !available;
      });

      updateGalleryForVariant(variant);
    };

    root.addEventListener('change', (e) => {
      const target = e.target;
      if (!(target instanceof HTMLInputElement)) return;
      if (target.type !== 'radio') return;

      setSelectedLabel();

      const options = getSelectedOptions();
      const variant = findVariant(options);
      updateUIForVariant(variant);
    });

    if (buyNowButton && atcButton) {
      buyNowButton.addEventListener('click', async () => {
        if (atcButton.disabled) return;

        const variantId = variantIdInput?.value;
        if (!variantId || typeof fetchConfig !== 'function' || !window.routes?.cart_add_url || !window.routes?.checkout_url) {
          atcButton.click();
          return;
        }

        buyNowButton.setAttribute('aria-disabled', 'true');
        buyNowButton.disabled = true;

        try {
          const formData = new FormData();
          formData.append('id', variantId);
          formData.append('quantity', '1');

          const config = fetchConfig('javascript');
          config.headers['X-Requested-With'] = 'XMLHttpRequest';
          delete config.headers['Content-Type'];
          config.body = formData;

          const response = await fetch(window.routes.cart_add_url, config);
          const data = await response.json();

          if (!response.ok || data?.status) {
            atcButton.click();
            return;
          }

          window.location.href = window.routes.checkout_url;
        } catch (error) {
          atcButton.click();
        } finally {
          buyNowButton.removeAttribute('aria-disabled');
          buyNowButton.disabled = atcButton.disabled;
        }
      });
    }

    const getAccordionItemParts = (item) => {
      if (!(item instanceof HTMLElement)) return { trigger: null, content: null };
      return {
        trigger: item.querySelector('[data-lusena-accordion-trigger]'),
        content: item.querySelector('[data-lusena-accordion-content]'),
      };
    };

    const updateAccordionContentHeight = (content) => {
      if (!(content instanceof HTMLElement)) return;
      const inner = content.firstElementChild instanceof HTMLElement ? content.firstElementChild : content;
      const measured = inner.scrollHeight;
      content.style.setProperty('--radix-accordion-content-height', `${Math.max(0, measured)}px`);
    };

    const ensureAccordionReady = (content) => {
      if (!(content instanceof HTMLElement)) return;
      if (content.hasAttribute('data-lusena-accordion-ready')) return;
      requestAnimationFrame(() => {
        content.setAttribute('data-lusena-accordion-ready', '');
      });
    };

    const observeAccordionContent = (content) => {
      if (!(content instanceof HTMLElement)) return;
      if (accordionContentObservers.has(content)) return;
      const inner = content.firstElementChild instanceof HTMLElement ? content.firstElementChild : content;

      if (typeof ResizeObserver === 'function' && inner) {
        const observer = new ResizeObserver(() => updateAccordionContentHeight(content));
        observer.observe(inner);
        accordionContentObservers.set(content, observer);
      }

      updateAccordionContentHeight(content);
      ensureAccordionReady(content);
    };

    const setAccordionContentState = (content, isOpen) => {
      if (!(content instanceof HTMLElement)) return;
      updateAccordionContentHeight(content);
      content.dataset.state = isOpen ? 'open' : 'closed';
    };

    const setAccordionItemState = (item, isOpen) => {
      if (!(item instanceof HTMLElement)) return;

      const { trigger, content } = getAccordionItemParts(item);
      const state = isOpen ? 'open' : 'closed';

      item.dataset.state = state;

      if (trigger instanceof HTMLElement) {
        trigger.dataset.state = state;
        trigger.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      }

      if (content instanceof HTMLElement) {
        setAccordionContentState(content, isOpen);
      }
    };

    const closeSiblingAccordionItems = (accordionRoot, currentItem) => {
      if (!(accordionRoot instanceof HTMLElement)) return;
      const items = Array.from(accordionRoot.querySelectorAll('[data-lusena-accordion-item]'));
      items.forEach((item) => {
        if (!(item instanceof HTMLElement) || item === currentItem) return;
        setAccordionItemState(item, false);
      });
    };

    const initializeAccordionRoot = (accordionRoot) => {
      if (!(accordionRoot instanceof HTMLElement)) return;

      const isSingle = accordionRoot.hasAttribute('data-lusena-accordion-single');
      const isCollapsible = accordionRoot.hasAttribute('data-lusena-accordion-collapsible');
      const items = Array.from(accordionRoot.querySelectorAll('[data-lusena-accordion-item]'));

      items.forEach((item) => {
        if (!(item instanceof HTMLElement)) return;
        setAccordionItemState(item, false);

        const { trigger } = getAccordionItemParts(item);
        if (!(trigger instanceof HTMLButtonElement)) return;

        const { content } = getAccordionItemParts(item);
        if (content instanceof HTMLElement) {
          observeAccordionContent(content);
        }

        trigger.addEventListener('click', () => {
          const currentlyOpen = item.dataset.state === 'open';

          if (currentlyOpen && isCollapsible) {
            setAccordionItemState(item, false);
            return;
          }

          if (isSingle) {
            closeSiblingAccordionItems(accordionRoot, item);
          }

          setAccordionItemState(item, true);
        });
      });
    };

    if (accordionRoots.length) {
      accordionRoots.forEach((accordionRoot) => {
        initializeAccordionRoot(accordionRoot);
      });
    }

    if (specDefinitionToggles.length) {
      specDefinitionToggles.forEach((toggleButton) => {
        if (!(toggleButton instanceof HTMLButtonElement)) return;

        toggleButton.addEventListener('click', () => {
          const specsTable = toggleButton.closest('[data-lusena-specs-table]');
          const key = toggleButton.dataset.specKey;
          if (!(specsTable instanceof HTMLElement) || !key) return;

          const definitionRow = specsTable.querySelector(
            `[data-lusena-spec-def-row][data-spec-key="${key}"]`
          );
          if (!(definitionRow instanceof HTMLElement)) return;

          const isOpen = !definitionRow.hidden;

          const rows = Array.from(specsTable.querySelectorAll('[data-lusena-spec-def-row]'));
          const buttons = Array.from(specsTable.querySelectorAll('[data-lusena-spec-def-toggle]'));

          rows.forEach((row) => {
            if (row instanceof HTMLElement) row.hidden = true;
          });

          buttons.forEach((button) => {
            if (button instanceof HTMLElement) {
              button.setAttribute('aria-expanded', 'false');
            }
          });

          if (!isOpen) {
            definitionRow.hidden = false;
            toggleButton.setAttribute('aria-expanded', 'true');
          }

          const content = specsTable.closest('[data-lusena-accordion-content]');
          if (content instanceof HTMLElement) {
            updateAccordionContentHeight(content);
          }
        });
      });
    }

    const openReturnsAccordion = () => {
      const detailsSection = document.getElementById('details');
      const returnsAccordion =
        detailsSection?.querySelector('[data-lusena-accordion-returns]') ||
        root.querySelector('[data-lusena-accordion-returns]') ||
        document.querySelector('[data-lusena-accordion-returns]');

      if (returnsAccordion instanceof HTMLElement) {
        if (returnsAccordion instanceof HTMLDetailsElement) {
          returnsAccordion.open = true;
        } else {
          const returnsRoot = returnsAccordion.closest('[data-lusena-accordion-root]');
          if (returnsRoot instanceof HTMLElement && returnsRoot.hasAttribute('data-lusena-accordion-single')) {
            closeSiblingAccordionItems(returnsRoot, returnsAccordion);
          }
          setAccordionItemState(returnsAccordion, true);
        }
      }

      if (detailsSection) {
        detailsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    };

    if (returnsLinks.length) {
      returnsLinks.forEach((link) => {
        link.addEventListener('click', (event) => {
          event.preventDefault();
          openReturnsAccordion();
        });
      });
    }

    const openLightboxFromActiveStage = () => {
      if (!state.visibleItems.length) return;
      const activeItem = state.visibleItems[state.activeIndex];
      if (!activeItem || activeItem.type !== 'media' || !isMediaZoomable(activeItem.media)) return;
      openLightboxByItemId(activeItem.id);
    };

    if (stageAction) {
      stageAction.addEventListener('click', (event) => {
        if (event.target instanceof HTMLElement && event.target.closest('a')) return;
        if (stageAction.dataset.lusenaStageZoomable !== 'true') return;
        openLightboxFromActiveStage();
      });

      stageAction.addEventListener('keydown', (event) => {
        if (stageAction.dataset.lusenaStageZoomable !== 'true') return;
        if (event.key !== 'Enter' && event.key !== ' ') return;
        event.preventDefault();
        openLightboxFromActiveStage();
      });
    }

    if (thumbEls.length) {
      thumbEls.forEach((el) => {
        el.addEventListener('click', () => {
          const id = el?.dataset?.mediaId ? String(el.dataset.mediaId) : null;
          if (!id) return;
          const idx = state.visibleItems.findIndex((item) => item.id === id);
          if (idx < 0) return;
          selectMediaIndex(idx, state.visibleItems, { instant: true });
        });
      });
    }

    if (mobileDotEls.length) {
      mobileDotEls.forEach((dot) => {
        dot.addEventListener('click', () => {
          const id = dot?.dataset?.mediaId ? String(dot.dataset.mediaId) : null;
          if (!id) return;
          const idx = state.visibleItems.findIndex((item) => item.id === id);
          if (idx < 0) return;
          selectMediaIndex(idx, state.visibleItems);
        });
      });
    }

    if (mobileSlideEls.length) {
      mobileSlideEls.forEach((slide) => {
        slide.addEventListener('click', (event) => {
          if (event.target instanceof HTMLElement && event.target.closest('a')) return;
          const id = slide?.dataset?.mediaId ? String(slide.dataset.mediaId) : null;
          if (!id) return;
          const idx = state.visibleItems.findIndex((item) => item.id === id);
          if (idx < 0) return;
          selectMediaIndex(idx, state.visibleItems, { instant: true });
          if (slide.hasAttribute('data-lusena-mobile-zoomable')) {
            openLightboxByItemId(id);
          }
        });
      });
    }

    if (mobileTrack) {
      let scrollFrame = null;
      mobileTrack.addEventListener(
        'scroll',
        () => {
          if (scrollFrame) return;
          scrollFrame = window.requestAnimationFrame(() => {
            scrollFrame = null;
            if (!state.visibleItems.length) return;
            const visibleSlides = state.visibleItems
              .map((item) => slidesById.get(item.id))
              .filter((slide) => slide && !slide.hidden);
            if (!visibleSlides.length) return;

            let closestIndex = 0;
            let closestDistance = Number.POSITIVE_INFINITY;
            const scrollLeft = mobileTrack.scrollLeft;

            visibleSlides.forEach((slide, index) => {
              const distance = Math.abs(slide.offsetLeft - scrollLeft);
              if (distance < closestDistance) {
                closestDistance = distance;
                closestIndex = index;
              }
            });

            if (closestIndex !== state.activeIndex) {
              selectMediaIndex(closestIndex, state.visibleItems, { scrollMobile: false, instant: true });
            }
          });
        },
        { passive: true }
      );
    }

    setSelectedLabel();
    updateUIForVariant(
      findVariant(getSelectedOptions()) ||
        product?.variants?.find((v) => String(v.id) === String(variantIdInput?.value || '')) ||
        product?.variants?.[0]
    );

    const mainCta = root.querySelector('#main-cta');
    if (!stickyBar || !mainCta) return;

    const show = () => stickyBar.classList.remove('translate-y-full');
    const hide = () => stickyBar.classList.add('translate-y-full');
    const hasPassedMainCta = () => {
      const rect = mainCta.getBoundingClientRect();
      return rect.bottom <= 0;
    };
    const syncStickyVisibility = () => {
      if (hasPassedMainCta()) show();
      else hide();
    };

    hide();

    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              hide();
              return;
            }

            if (entry.boundingClientRect.bottom <= 0) show();
            else hide();
          });
        },
        { threshold: 0 }
      );
      io.observe(mainCta);
      syncStickyVisibility();
      return;
    }

    const onScroll = () => {
      syncStickyVisibility();
    };
    onScroll();
    window.addEventListener('scroll', onScroll, { passive: true });
  })();
{% endjavascript %}
