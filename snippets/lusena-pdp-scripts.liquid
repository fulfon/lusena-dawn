{% doc %}
  PDP behavior (variant selection, price updates, gallery switching, sticky ATC).
{% enddoc %}

{% javascript %}
  (() => {
    const root = document.querySelector('[data-lusena-product-section]');
    if (!root) return;

    const productJsonEl = root.querySelector('[data-lusena-product-json]');
    const variantIdInput = root.querySelector('[data-lusena-variant-id]');
    const priceEl = root.querySelector('[data-lusena-price]');
    const compareAtEl = root.querySelector('[data-lusena-compare-at]');
    const pricePerNightEl = root.querySelector('[data-lusena-price-per-night]');
    const stickyBar = root.querySelector('[data-lusena-sticky-atc]');
    const stickyPrices = Array.from(root.querySelectorAll('[data-lusena-sticky-price]'));
    const stickyPricePerNights = Array.from(root.querySelectorAll('[data-lusena-sticky-price-per-night]'));
    const stickyVariants = Array.from(root.querySelectorAll('[data-lusena-sticky-variant]'));
    const stickyImages = Array.from(root.querySelectorAll('[data-lusena-sticky-image]'));
    const stockText = root.querySelector('[data-lusena-stock-text]');
    const stockDot = root.querySelector('[data-lusena-stock-dot]');
    const atcButton = root.querySelector('[data-lusena-atc]');
    const buyNowButton = root.querySelector('[data-lusena-buy-now]');
    const addToCartFormEl = root.querySelector('product-form form[data-type="add-to-cart-form"]');
    const stickyAtcButtons = Array.from(root.querySelectorAll('[data-lusena-sticky-atc-button]'));
    const returnsLinks = Array.from(root.querySelectorAll('[data-lusena-open-returns]'));
    const accordionRoots = Array.from(document.querySelectorAll('[data-lusena-accordion-root]'));
    const specDefinitionToggles = Array.from(document.querySelectorAll('[data-lusena-spec-def-toggle]'));
    const prefersReducedMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches;

    const pricePerNightPrefix = pricePerNightEl?.dataset?.prefix ?? '';
    const pricePerNightSuffix = pricePerNightEl?.dataset?.suffix ?? '';
    const stickyPricePerNightPrefix = stickyPricePerNights[0]?.dataset?.prefix ?? pricePerNightPrefix;
    const stickyPricePerNightSuffix = stickyPricePerNights[0]?.dataset?.suffix ?? pricePerNightSuffix;

    let product;
    try {
      product = JSON.parse(productJsonEl.textContent);
    } catch (e) {
      return;
    }

    const galleryRoot = root.querySelector('[data-lusena-gallery]');
    const stage = root.querySelector('[data-lusena-media-stage]');
    const stageContent = root.querySelector('[data-lusena-stage-content]');
    const stageAction = root.querySelector('[data-lusena-stage-action]');
    const stageImg = root.querySelector('[data-lusena-media-stage] img');
    const stageProof = root.querySelector('[data-lusena-stage-proof]');
    const stageBadge = root.querySelector('[data-lusena-stage-bestseller]');
    const stageSizes = stageImg?.getAttribute('sizes') || '';
    const proofId = galleryRoot?.dataset?.lusenaProofId ? String(galleryRoot.dataset.lusenaProofId) : null;
    const isBestseller = !!stageBadge || root.querySelectorAll('[data-lusena-mobile-bestseller]').length > 0;
    const lightboxRoot = root.querySelector('[data-lusena-lightbox]');
    const lightboxViewport = root.querySelector('[data-lusena-lightbox-viewport]');
    const lightboxCounter = root.querySelector('[data-lusena-lightbox-counter]');
    const lightboxCloseButton = root.querySelector('[data-lusena-lightbox-close]');
    const lightboxPrevButton = root.querySelector('[data-lusena-lightbox-prev]');
    const lightboxNextButton = root.querySelector('[data-lusena-lightbox-next]');
    const lightboxImageWrap = root.querySelector('[data-lusena-lightbox-image-wrap]');
    const lightboxImage = root.querySelector('[data-lusena-lightbox-image]');
    const lightboxFallback = root.querySelector('[data-lusena-lightbox-fallback]');
    const lightboxHintDesktop = root.querySelector('[data-lusena-lightbox-hint-desktop]');
    const lightboxHintMobile = root.querySelector('[data-lusena-lightbox-hint-mobile]');

    if (lightboxRoot && lightboxRoot.parentElement !== document.body) {
      document.body.appendChild(lightboxRoot);
    }

    const desktopThumbsWrap = root.querySelector('[data-lusena-media-thumbs-desktop]');
    const thumbEls = desktopThumbsWrap ? Array.from(desktopThumbsWrap.querySelectorAll('[data-lusena-thumb]')) : [];
    const thumbsById = new Map(
      thumbEls
        .map((el) => {
          const id = el?.dataset?.mediaId;
          return id ? [String(id), el] : null;
        })
        .filter(Boolean)
    );

    const mobileTrack = root.querySelector('[data-lusena-mobile-track]');
    const mobileSlideEls = mobileTrack ? Array.from(mobileTrack.querySelectorAll('[data-lusena-mobile-slide]')) : [];
    const slidesById = new Map(
      mobileSlideEls
        .map((el) => {
          const id = el?.dataset?.mediaId;
          return id ? [String(id), el] : null;
        })
        .filter(Boolean)
    );

    const mobileDotsWrap = root.querySelector('[data-lusena-mobile-dots]');
    const mobileDotEls = mobileDotsWrap ? Array.from(mobileDotsWrap.querySelectorAll('[data-lusena-mobile-dot]')) : [];
    const dotsById = new Map(
      mobileDotEls
        .map((el) => {
          const id = el?.dataset?.mediaId;
          return id ? [String(id), el] : null;
        })
        .filter(Boolean)
    );

    const STAGE_CROSSFADE_MS = 300;
    const BUY_NOW_LOADING_MIN_MS = 500;
    const BUY_NOW_LOADING_HOLD_MS = 350;
    const parseDelayMs = (value) => {
      const parsed = Number.parseInt(value, 10);
      if (!Number.isFinite(parsed) || parsed < 0) return 0;
      return parsed;
    };
    const addToCartLoadingMinMs = parseDelayMs(addToCartFormEl?.dataset?.loadingMinMs);
    const addToCartLoadingHoldMs = parseDelayMs(addToCartFormEl?.dataset?.loadingHoldMs);
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    let stageFadeTimer = null;
    let mobileFadeTimer = null;
    let stickyLoadingTimer = null;
    let stickyLoadingStartedAt = null;
    const wait = (ms) =>
      new Promise((resolve) => {
        window.setTimeout(resolve, ms);
      });

    const normalizeImageUrl = (src) => {
      if (!src) return null;
      if (src.startsWith('//')) return `https:${src}`;
      return src;
    };

    const urlWithWidth = (src, width) => {
      const normalized = normalizeImageUrl(src);
      if (!normalized) return null;
      try {
        const u = new URL(normalized);
        u.searchParams.set('width', String(width));
        return u.toString();
      } catch (e) {
        return normalized;
      }
    };

    const setResponsiveImage = ({ img, src, widths, sizes, alt }) => {
      if (!img || !src) return;
      const normalized = normalizeImageUrl(src);
      if (!normalized) return;

      const maxWidth = widths[widths.length - 1];
      const srcWithWidth = urlWithWidth(normalized, maxWidth);
      const srcset = widths
        .map((w) => {
          const u = urlWithWidth(normalized, w);
          return u ? `${u} ${w}w` : null;
        })
        .filter(Boolean)
        .join(', ');

      if (srcWithWidth) img.src = srcWithWidth;
      if (srcset) img.setAttribute('srcset', srcset);
      if (sizes) img.setAttribute('sizes', sizes);
      if (typeof alt === 'string') img.alt = alt;
    };

    const findMediaById = (mediaId) => {
      if (!mediaId) return null;
      const idString = String(mediaId);
      return product?.media?.find((m) => String(m?.id) === idString) || null;
    };

    const normalizeKey = (value) => (typeof value === 'string' ? value.trim().toLowerCase() : '');

    const parseAlt = (alt) => {
      const raw = typeof alt === 'string' ? alt : '';
      const parts = raw.split('|').map((p) => p.trim()).filter(Boolean);

      const cleanAltCandidate = parts.length ? parts[0] : '';
      const cleanAltLooksLikeTag = /^\[(shared|color\s*=)/i.test(cleanAltCandidate);
      const cleanAlt = parts.length > 1 ? cleanAltCandidate : cleanAltLooksLikeTag ? '' : cleanAltCandidate;

      const tagText = parts.length > 1 ? parts[parts.length - 1] : raw;
      const shared = /\[shared\]/i.test(tagText);
      const colorMatch = tagText.match(/\[color\s*=\s*([^\]]+)\]/i);
      const colorTag = colorMatch ? colorMatch[1].trim() : null;

      return { cleanAlt, shared, colorTag };
    };

    const getMediaAltRaw = (media) => media?.alt || media?.preview_image?.alt || '';

    const hasAnyTagging = () =>
      Array.isArray(product?.media) && product.media.some((m) => /\[(shared|color\s*=)/i.test(getMediaAltRaw(m)));

    const taggingEnabled = hasAnyTagging();

    const getColorOptionIndex = () => {
      const fieldset = root.querySelector('[data-lusena-option-type="color"]');
      if (!fieldset) return null;
      const idx = Number(fieldset.dataset.optionIndex);
      return Number.isFinite(idx) ? idx : null;
    };

    const getSelectedColorForVariant = (variant) => {
      const colorIndex = getColorOptionIndex();
      if (colorIndex === null) return null;
      const options = variant?.options;
      if (!Array.isArray(options)) return null;
      return options[colorIndex] || null;
    };

    const getStickyVariantLabel = (variant) => {
      const selectedColor = getSelectedColorForVariant(variant);
      if (selectedColor) return selectedColor;
      if (Array.isArray(variant?.options) && variant.options.length) return variant.options[0] || variant?.title || '';
      return variant?.title || '';
    };

    const getVariantImageSrc = (variant) => {
      if (!variant) return null;

      if (variant?.featured_image && typeof variant.featured_image === 'object' && variant.featured_image.src) {
        return variant.featured_image.src;
      }

      const featuredMediaId =
        variant?.featured_media && typeof variant.featured_media === 'object' ? variant.featured_media.id : variant?.featured_media;
      if (featuredMediaId) {
        const featuredMedia = findMediaById(featuredMediaId);
        if (featuredMedia) return featuredMedia?.preview_image?.src || featuredMedia?.src || null;
      }

      return product?.featured_image?.src || product?.featured_media?.preview_image?.src || null;
    };

    const getVisibleMediaForColor = (color) => {
      const media = Array.isArray(product?.media) ? product.media : [];
      if (!media.length) return { colorMedia: [], sharedMedia: [], visible: [], taggingEnabled: false };

      if (!taggingEnabled || !color) {
        return { colorMedia: [], sharedMedia: [], visible: media, taggingEnabled };
      }

      const normalizedColor = normalizeKey(color);
      const colorMedia = [];
      const sharedMedia = [];

      media.forEach((m) => {
        const { shared, colorTag } = parseAlt(getMediaAltRaw(m));
        const isSharedEffective = shared || (!colorTag && taggingEnabled);

        if (colorTag && normalizeKey(colorTag) === normalizedColor) colorMedia.push(m);
        else if (isSharedEffective) sharedMedia.push(m);
      });

      const visible = colorMedia.length ? [...colorMedia, ...sharedMedia] : sharedMedia.length ? sharedMedia : media;
      return { colorMedia, sharedMedia, visible, taggingEnabled };
    };

    const state = {
      activeIndex: 0,
      colorMediaLength: 0,
      activeKind: 'color',
      initialized: false,
      visibleItems: [],
      visibleItemsKey: '',
    };

    const LIGHTBOX_HASH = '#lightbox';
    const LIGHTBOX_DESKTOP_MAX_ZOOM = 1.5;
    const LIGHTBOX_MOBILE_MAX_ZOOM = 2.5;
    const LIGHTBOX_MIN_ZOOM = 1;

    const lightboxState = {
      open: false,
      slides: [],
      index: 0,
      openedAt: 0,
      zoom: 1,
      translate: { x: 0, y: 0 },
      imageLoaded: false,
      imageError: false,
      pinch: null,
      pan: null,
      lastTapAt: 0,
      touchStart: null,
      scrollY: 0,
    };

    const isMediaZoomable = (media) => media?.media_type === 'image';

    const buildVisibleItems = (visibleMedia) => {
      const items = visibleMedia.map((media) => ({
        id: String(media?.id),
        type: 'media',
        media,
      }));

      if (proofId) {
        items.push({
          id: proofId,
          type: 'proof',
        });
      }

      return items;
    };

    const clearStageFadeTimer = () => {
      if (stageFadeTimer) {
        window.clearTimeout(stageFadeTimer);
        stageFadeTimer = null;
      }
    };

    const clearMobileFadeTimer = () => {
      if (mobileFadeTimer) {
        window.clearTimeout(mobileFadeTimer);
        mobileFadeTimer = null;
      }
    };

    const buildVisibleItemsKey = (visibleItems) => visibleItems.map((item) => item.id).join('|');

    const setMobileTrackFade = (isVisible) => {
      if (!mobileTrack) return;
      mobileTrack.dataset.fadeState = isVisible ? 'in' : 'out';
    };

    const syncMobileSlideLoading = (visibleItems) => {
      visibleItems.forEach((item, index) => {
        const slide = slidesById.get(item.id);
        if (!slide || slide.hidden) return;
        const slideImage = slide.querySelector('img');
        if (!(slideImage instanceof HTMLImageElement)) return;

        if (item.type === 'media' && index === 0) {
          slideImage.loading = 'eager';
          slideImage.setAttribute('fetchpriority', 'high');
          return;
        }

        slideImage.loading = 'lazy';
        slideImage.removeAttribute('fetchpriority');
      });
    };

    const setActiveThumb = (activeItemId) => {
      thumbEls.forEach((el) => el.removeAttribute('aria-current'));
      if (!activeItemId) return;
      const el = thumbsById.get(String(activeItemId));
      if (el) el.setAttribute('aria-current', 'true');
    };

    const setActiveDot = (activeItemId) => {
      mobileDotEls.forEach((el) => el.removeAttribute('aria-current'));
      if (!activeItemId) return;
      const el = dotsById.get(String(activeItemId));
      if (el && !el.hidden) el.setAttribute('aria-current', 'true');
    };

    const setDesktopBestseller = (isVisible) => {
      if (!stageBadge) return;
      stageBadge.hidden = !isVisible;
    };

    const setMobileBestseller = (visibleItems) => {
      root.querySelectorAll('[data-lusena-mobile-bestseller]').forEach((badge) => {
        badge.hidden = true;
      });

      if (!isBestseller || !visibleItems.length) return;
      const firstSlide = slidesById.get(visibleItems[0].id);
      const firstBadge = firstSlide?.querySelector('[data-lusena-mobile-bestseller]');
      if (firstBadge) firstBadge.hidden = false;
    };

    const applyDesktopThumbOrderAndVisibility = (visibleItems) => {
      if (!desktopThumbsWrap) return;
      const visibleIds = new Set(visibleItems.map((item) => item.id));

      thumbEls.forEach((el) => {
        const id = String(el?.dataset?.mediaId || '');
        el.hidden = !visibleIds.has(id);
      });

      visibleItems.forEach((item) => {
        const el = thumbsById.get(item.id);
        if (el) desktopThumbsWrap.appendChild(el);
      });
    };

    const applyMobileOrderAndVisibility = (visibleItems) => {
      if (!mobileTrack) return;
      const visibleIds = new Set(visibleItems.map((item) => item.id));

      mobileSlideEls.forEach((slide) => {
        const id = String(slide?.dataset?.mediaId || '');
        slide.hidden = !visibleIds.has(id);
      });

      visibleItems.forEach((item) => {
        const slide = slidesById.get(item.id);
        if (slide) mobileTrack.appendChild(slide);
      });

      mobileDotEls.forEach((dot) => {
        const id = String(dot?.dataset?.mediaId || '');
        dot.hidden = !visibleIds.has(id);
      });

      visibleItems.forEach((item) => {
        const dot = dotsById.get(item.id);
        if (dot && mobileDotsWrap) mobileDotsWrap.appendChild(dot);
      });

      syncMobileSlideLoading(visibleItems);

      if (mobileDotsWrap) {
        mobileDotsWrap.hidden = visibleItems.length <= 1;
      }
    };

    const applyGalleryOrderAndVisibility = (visibleItems) => {
      applyDesktopThumbOrderAndVisibility(visibleItems);
      applyMobileOrderAndVisibility(visibleItems);
      setMobileBestseller(visibleItems);
      state.visibleItems = visibleItems;
    };

    const setStageByMedia = (media) => {
      if (!stageImg || !media) return;
      const src = media?.preview_image?.src || media?.src;
      if (!src) return;

      const { cleanAlt } = parseAlt(getMediaAltRaw(media));
      stageImg.loading = 'eager';
      stageImg.setAttribute('fetchpriority', 'high');
      setResponsiveImage({
        img: stageImg,
        src,
        widths: [600, 800, 1200, 1600],
        sizes: stageSizes,
        alt: cleanAlt,
      });
    };

    const setStageByItem = (item) => {
      if (!stage || !item) return;

      const setStageActionState = (isZoomable) => {
        if (!stageAction) return;
        stageAction.dataset.lusenaStageZoomable = isZoomable ? 'true' : 'false';
        if (isZoomable) {
          stageAction.setAttribute('role', 'button');
          stageAction.setAttribute('tabindex', '0');
          stageAction.setAttribute('aria-label', 'Powieksz zdjecie produktu');
        } else {
          stageAction.removeAttribute('role');
          stageAction.removeAttribute('tabindex');
          stageAction.removeAttribute('aria-label');
        }
      };

      if (item.type === 'proof') {
        stage.dataset.stageType = 'proof';
        if (stageProof) stageProof.hidden = false;
        setStageActionState(false);
        return;
      }

      stage.dataset.stageType = 'image';
      if (stageProof) stageProof.hidden = true;
      setStageActionState(isMediaZoomable(item.media));
      setStageByMedia(item.media);
    };

    const transitionStageToItem = (item, options = {}) => {
      if (!stage || !item) return;
      const useCrossfade = options.crossfade === true && !prefersReducedMotion && !!stageContent;

      clearStageFadeTimer();
      if (!useCrossfade) {
        stage.dataset.stageFade = 'in';
        setStageByItem(item);
        return;
      }

      stage.dataset.stageFade = 'out';
      stageFadeTimer = window.setTimeout(() => {
        setStageByItem(item);
        stage.dataset.stageFade = 'in';
        stageFadeTimer = null;
      }, STAGE_CROSSFADE_MS);
    };

    const scrollMobileToItem = (itemId, behavior = 'smooth') => {
      if (!mobileTrack || !itemId) return;
      const slide = slidesById.get(String(itemId));
      if (!slide || slide.hidden) return;
      mobileTrack.scrollTo({ left: slide.offsetLeft, behavior });
    };

    const selectMediaIndex = (index, visibleItems, options = {}) => {
      if (!visibleItems.length) return;
      const safeIndex = Math.max(0, Math.min(index, visibleItems.length - 1));
      const item = visibleItems[safeIndex];
      state.activeIndex = safeIndex;

      if (item.type === 'proof') {
        state.activeKind = 'proof';
      } else if (!taggingEnabled) {
        state.activeKind = 'color';
      } else if (state.colorMediaLength > 0 && safeIndex < state.colorMediaLength) {
        state.activeKind = 'color';
      } else {
        state.activeKind = 'shared';
      }

      transitionStageToItem(item, { crossfade: options.crossfade === true });
      setActiveThumb(item.id);
      setActiveDot(item.id);
      setDesktopBestseller(isBestseller && safeIndex === 0);

      if (options.scrollMobile !== false) {
        scrollMobileToItem(item.id, options.instant ? 'auto' : 'smooth');
      }
    };

    const isTouchDevice = () => window.matchMedia('(pointer: coarse)').matches;

    const getLightboxMaxZoom = () => (isTouchDevice() ? LIGHTBOX_MOBILE_MAX_ZOOM : LIGHTBOX_DESKTOP_MAX_ZOOM);

    const getLightboxSlides = () =>
      state.visibleItems
        .filter((item) => item.type === 'media' && isMediaZoomable(item.media))
        .map((item) => {
          const media = item.media;
          const src = media?.src || media?.preview_image?.src;
          const { cleanAlt } = parseAlt(getMediaAltRaw(media));
          const width = Number(media?.preview_image?.width || media?.width || 0);
          const height = Number(media?.preview_image?.height || media?.height || 0);
          return {
            id: item.id,
            src: normalizeImageUrl(src),
            alt: cleanAlt || product?.title || '',
            width,
            height,
          };
        })
        .filter((slide) => !!slide.src);

    const updateLightboxHintText = () => {
      const isZoomed = lightboxState.zoom > 1;
      if (lightboxHintDesktop) {
        lightboxHintDesktop.textContent = isZoomed ? 'Kliknij aby oddalic' : 'Kliknij aby powiekszyc';
      }
      if (lightboxHintMobile) {
        lightboxHintMobile.textContent = isZoomed
          ? 'Dotknij dwukrotnie aby oddalic'
          : 'Dotknij dwukrotnie lub rozsun palce';
      }
    };

    const getLightboxMaxTranslate = (zoomValue) => {
      if (!lightboxViewport || zoomValue <= 1) return { x: 0, y: 0 };
      const baseRect = getLightboxInteractionRect();
      if (!baseRect) return { x: 0, y: 0 };
      return {
        x: Math.max(0, (zoomValue * baseRect.width - lightboxViewport.clientWidth) / (2 * zoomValue)),
        y: Math.max(0, (zoomValue * baseRect.height - lightboxViewport.clientHeight) / (2 * zoomValue)),
      };
    };

    const clampLightboxTranslate = (tx, ty, zoomValue) => {
      const max = getLightboxMaxTranslate(zoomValue);
      return {
        x: Math.max(-max.x, Math.min(max.x, tx)),
        y: Math.max(-max.y, Math.min(max.y, ty)),
      };
    };

    const applyLightboxTransform = () => {
      if (!lightboxImage) return;
      lightboxImage.style.transform = `scale(${lightboxState.zoom}) translate(${lightboxState.translate.x}px, ${lightboxState.translate.y}px)`;
      lightboxImage.classList.toggle('is-zoomed', lightboxState.zoom > 1);
      if (lightboxRoot) lightboxRoot.classList.toggle('is-zoomed', lightboxState.zoom > 1);
      updateLightboxHintText();
    };

    const resetLightboxZoom = () => {
      lightboxState.zoom = LIGHTBOX_MIN_ZOOM;
      lightboxState.translate = { x: 0, y: 0 };
      applyLightboxTransform();
    };

    const syncLightboxNav = () => {
      if (!lightboxPrevButton || !lightboxNextButton) return;
      lightboxPrevButton.disabled = lightboxState.index <= 0;
      lightboxNextButton.disabled = lightboxState.index >= lightboxState.slides.length - 1;
    };

    const setLightboxCounter = () => {
      if (!lightboxCounter) return;
      if (lightboxState.slides.length > 1) {
        lightboxCounter.textContent = `${lightboxState.index + 1} / ${lightboxState.slides.length}`;
      } else {
        lightboxCounter.textContent = '';
      }
    };

    const renderLightboxError = (message) => {
      if (!lightboxImageWrap) return;
      lightboxState.imageError = true;
      lightboxState.imageLoaded = false;
      lightboxImageWrap.classList.add('is-error');
      lightboxImageWrap.classList.remove('is-loaded');
      if (lightboxFallback) {
        lightboxFallback.textContent = message;
        lightboxFallback.hidden = false;
      }
    };

    const renderLightboxSlide = ({ resetZoom = false } = {}) => {
      if (!lightboxImageWrap || !lightboxImage) return;
      const slide = lightboxState.slides[lightboxState.index];
      lightboxState.imageLoaded = false;
      lightboxState.imageError = false;
      lightboxImageWrap.classList.remove('is-loaded', 'is-error');
      if (lightboxFallback) lightboxFallback.hidden = true;

      if (resetZoom) resetLightboxZoom();
      setLightboxCounter();
      syncLightboxNav();

      if (!slide?.src) {
        renderLightboxError('Brak zdjecia');
        return;
      }

      if (Number.isFinite(slide.width) && Number.isFinite(slide.height) && slide.width > 0 && slide.height > 0) {
        lightboxImage.setAttribute('width', String(slide.width));
        lightboxImage.setAttribute('height', String(slide.height));
      }

      lightboxImage.src = slide.src;
      lightboxImage.alt = slide.alt || '';
    };

    const lockBodyForLightbox = () => {
      lightboxState.scrollY = window.scrollY;
      document.body.style.position = 'fixed';
      document.body.style.top = `-${lightboxState.scrollY}px`;
      document.body.style.width = '100%';
      document.body.style.overflow = 'hidden';
    };

    const unlockBodyForLightbox = () => {
      document.body.style.position = '';
      document.body.style.top = '';
      document.body.style.width = '';
      document.body.style.overflow = '';
      window.scrollTo(0, lightboxState.scrollY || 0);
    };

    const closeLightbox = (fromPopstate = false) => {
      if (!lightboxState.open || !lightboxRoot) return;
      lightboxState.open = false;
      lightboxState.openedAt = 0;
      lightboxRoot.classList.remove('is-visible', 'is-zoomed', 'is-over-image');
      window.setTimeout(() => {
        if (!lightboxState.open) lightboxRoot.hidden = true;
      }, 200);

      unlockBodyForLightbox();

      if (!fromPopstate && location.hash === LIGHTBOX_HASH) {
        history.replaceState(null, '', `${location.pathname}${location.search}`);
      }
    };

    const navigateLightbox = (direction) => {
      if (!lightboxState.open) return;
      const nextIndex = lightboxState.index + direction;
      if (nextIndex < 0 || nextIndex >= lightboxState.slides.length) return;
      lightboxState.index = nextIndex;
      renderLightboxSlide({ resetZoom: true });
    };

    const openLightboxByItemId = (itemId) => {
      if (!lightboxRoot || !itemId) return;
      const slides = getLightboxSlides();
      if (!slides.length) return;

      const nextIndex = slides.findIndex((slide) => slide.id === String(itemId));
      if (nextIndex < 0) return;

      lightboxState.slides = slides;
      lightboxState.index = nextIndex;
      lightboxState.open = true;
      lightboxState.openedAt = Date.now();
      lightboxRoot.hidden = false;
      setLightboxHoverState(false);
      lockBodyForLightbox();
      renderLightboxSlide({ resetZoom: true });
      requestAnimationFrame(() => {
        lightboxRoot.classList.add('is-visible');
      });

      if (location.hash !== LIGHTBOX_HASH) {
        history.pushState(null, '', `${location.pathname}${location.search}${LIGHTBOX_HASH}`);
      }

      window.setTimeout(() => {
        lightboxCloseButton?.focus();
      }, 80);
    };

    const refreshLightboxSlides = () => {
      if (!lightboxState.open) return;
      const activeSlideId = lightboxState.slides[lightboxState.index]?.id || null;
      const refreshedSlides = getLightboxSlides();
      if (!refreshedSlides.length) {
        closeLightbox();
        return;
      }

      lightboxState.slides = refreshedSlides;
      const remappedIndex = activeSlideId ? refreshedSlides.findIndex((slide) => slide.id === activeSlideId) : -1;
      if (remappedIndex >= 0) {
        lightboxState.index = remappedIndex;
      } else if (lightboxState.index > refreshedSlides.length - 1) {
        lightboxState.index = refreshedSlides.length - 1;
      }
      renderLightboxSlide({ resetZoom: true });
    };

    const getTouchDistance = (touches) => {
      if (!touches || touches.length < 2) return 0;
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    };

    const setLightboxHoverState = (isOverImage) => {
      if (!lightboxRoot) return;
      lightboxRoot.classList.toggle('is-over-image', !!isOverImage);
    };

    const getLightboxInteractionRect = () => {
      if (!lightboxImage || !lightboxViewport || !lightboxState.imageLoaded || lightboxState.imageError) return null;

      const viewportRect = lightboxViewport.getBoundingClientRect();
      if (viewportRect.width <= 0 || viewportRect.height <= 0) return null;

      const intrinsicWidth = Number(lightboxImage.naturalWidth || lightboxImage.getAttribute('width') || 0);
      const intrinsicHeight = Number(lightboxImage.naturalHeight || lightboxImage.getAttribute('height') || 0);

      const maxRenderWidth = Math.min(viewportRect.width, window.innerWidth * 0.9);
      const maxRenderHeight = Math.min(viewportRect.height, window.innerHeight * 0.85);

      let renderWidth = maxRenderWidth;
      let renderHeight = maxRenderHeight;

      if (intrinsicWidth > 0 && intrinsicHeight > 0) {
        const scale = Math.min(maxRenderWidth / intrinsicWidth, maxRenderHeight / intrinsicHeight, 1);
        renderWidth = intrinsicWidth * scale;
        renderHeight = intrinsicHeight * scale;
      }

      const left = viewportRect.left + (viewportRect.width - renderWidth) / 2;
      const top = viewportRect.top + (viewportRect.height - renderHeight) / 2;
      return {
        left,
        top,
        right: left + renderWidth,
        bottom: top + renderHeight,
        width: renderWidth,
        height: renderHeight,
      };
    };

    const isPointInsideLightboxImage = (clientX, clientY) => {
      const rect = getLightboxInteractionRect();
      if (!rect) return false;
      const edgeTolerance = 2;
      return (
        clientX >= rect.left - edgeTolerance &&
        clientX <= rect.right + edgeTolerance &&
        clientY >= rect.top - edgeTolerance &&
        clientY <= rect.bottom + edgeTolerance
      );
    };

    const handleDesktopLightboxImageClick = (event) => {
      if (!lightboxState.open) return;
      if (Date.now() - lightboxState.openedAt < 220) return;

      if (lightboxState.zoom > 1) {
        resetLightboxZoom();
        return;
      }

      const zoomLevel = getLightboxMaxZoom();
      const rect = getLightboxInteractionRect();
      if (!rect || rect.width <= 0 || rect.height <= 0) return;
      const clickX = (event.clientX - rect.left) / rect.width;
      const clickY = (event.clientY - rect.top) / rect.height;
      const max = getLightboxMaxTranslate(zoomLevel);
      lightboxState.zoom = zoomLevel;
      lightboxState.translate = clampLightboxTranslate((0.5 - clickX) * 2 * max.x, (0.5 - clickY) * 2 * max.y, zoomLevel);
      applyLightboxTransform();
    };

    if (lightboxRoot) {
      lightboxRoot.addEventListener('click', (event) => {
        if (!lightboxState.open) return;
        const onTouchDevice = isTouchDevice();

        const target =
          event.target instanceof Element
            ? event.target
            : event.target && event.target.parentElement instanceof Element
              ? event.target.parentElement
              : null;
        if (!target) {
          closeLightbox();
          return;
        }

        if (target.closest('[data-lusena-lightbox-close], [data-lusena-lightbox-prev], [data-lusena-lightbox-next]')) {
          return;
        }

        if (target.closest('.lusena-lightbox__top, .lusena-lightbox__bottom')) {
          closeLightbox();
          return;
        }

        const clickedInsideImage = isPointInsideLightboxImage(event.clientX, event.clientY);

        if (onTouchDevice) {
          if (lightboxState.zoom <= 1 && !clickedInsideImage) {
            closeLightbox();
          }
          return;
        }

        if (clickedInsideImage) {
          handleDesktopLightboxImageClick(event);
          return;
        }

        closeLightbox();
      });
    }

    const handleLightboxPopState = () => {
      if (lightboxState.open) closeLightbox(true);
    };

    const handleLightboxKeydown = (event) => {
      if (!lightboxState.open) return;

      if (event.key === 'Escape') {
        event.preventDefault();
        closeLightbox();
        return;
      }

      if (event.key === 'ArrowLeft') {
        event.preventDefault();
        navigateLightbox(-1);
        return;
      }

      if (event.key === 'ArrowRight') {
        event.preventDefault();
        navigateLightbox(1);
        return;
      }

      if (event.key === 'Tab' && lightboxRoot) {
        const focusable = Array.from(
          lightboxRoot.querySelectorAll('button:not([disabled]):not([hidden]), [tabindex]:not([tabindex="-1"])')
        );
        if (!focusable.length) return;

        const first = focusable[0];
        const last = focusable[focusable.length - 1];

        if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        } else if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        }
      }
    };

    if (lightboxImage) {
      lightboxImage.addEventListener('load', () => {
        if (!lightboxState.open || !lightboxImageWrap) return;
        lightboxState.imageLoaded = true;
        lightboxState.imageError = false;
        lightboxImageWrap.classList.add('is-loaded');
        lightboxImageWrap.classList.remove('is-error');
      });

      lightboxImage.addEventListener('error', () => {
        if (!lightboxState.open) return;
        renderLightboxError('Nie udalo sie zaladowac zdjecia');
      });
    }

    if (lightboxViewport) {
      lightboxViewport.addEventListener('mousemove', (event) => {
        if (!lightboxState.open || isTouchDevice()) return;
        const insideImage = isPointInsideLightboxImage(event.clientX, event.clientY);
        setLightboxHoverState(insideImage);
        if (lightboxState.zoom <= 1 || !insideImage) return;
        const rect = getLightboxInteractionRect();
        if (!rect || rect.width <= 0 || rect.height <= 0) return;
        const x = Math.max(0, Math.min(1, (event.clientX - rect.left) / rect.width));
        const y = Math.max(0, Math.min(1, (event.clientY - rect.top) / rect.height));
        const max = getLightboxMaxTranslate(lightboxState.zoom);
        lightboxState.translate = {
          x: (0.5 - x) * 2 * max.x,
          y: (0.5 - y) * 2 * max.y,
        };
        applyLightboxTransform();
      });

      lightboxViewport.addEventListener('mouseleave', () => {
        setLightboxHoverState(false);
      });

      lightboxViewport.addEventListener(
        'touchstart',
        (event) => {
          if (!lightboxState.open) return;
          if (event.touches.length === 2) {
            lightboxState.pinch = {
              startDist: getTouchDistance(event.touches),
              startZoom: lightboxState.zoom,
            };
            return;
          }

          if (event.touches.length === 1) {
            const touch = event.touches[0];
            const now = Date.now();
            lightboxState.touchStart = { x: touch.clientX, y: touch.clientY, time: now };
            if (lightboxState.zoom > 1) {
              lightboxState.pan = {
                startX: touch.clientX,
                startY: touch.clientY,
                startTx: lightboxState.translate.x,
                startTy: lightboxState.translate.y,
              };
            }
          }
        },
        { passive: true }
      );

      lightboxViewport.addEventListener(
        'touchmove',
        (event) => {
          if (!lightboxState.open) return;
          if (event.touches.length === 2 && lightboxState.pinch) {
            const nextDistance = getTouchDistance(event.touches);
            const scaled = Math.min(
              Math.max((nextDistance / lightboxState.pinch.startDist) * lightboxState.pinch.startZoom, LIGHTBOX_MIN_ZOOM),
              LIGHTBOX_MOBILE_MAX_ZOOM
            );
            lightboxState.zoom = scaled;
            const midX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
            const midY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
            const rect = getLightboxInteractionRect() || lightboxViewport.getBoundingClientRect();
            const relX = (midX - rect.left) / rect.width;
            const relY = (midY - rect.top) / rect.height;
            const max = getLightboxMaxTranslate(scaled);
            lightboxState.translate = clampLightboxTranslate((0.5 - relX) * 2 * max.x, (0.5 - relY) * 2 * max.y, scaled);
            applyLightboxTransform();
            return;
          }

          if (event.touches.length === 1 && lightboxState.zoom > 1 && lightboxState.pan) {
            const touch = event.touches[0];
            const dx = (touch.clientX - lightboxState.pan.startX) / lightboxState.zoom;
            const dy = (touch.clientY - lightboxState.pan.startY) / lightboxState.zoom;
            lightboxState.translate = clampLightboxTranslate(
              lightboxState.pan.startTx + dx,
              lightboxState.pan.startTy + dy,
              lightboxState.zoom
            );
            applyLightboxTransform();
          }
        },
        { passive: true }
      );

      lightboxViewport.addEventListener(
        'touchend',
        (event) => {
          if (!lightboxState.open) return;

          if (lightboxState.pinch && event.touches.length < 2) {
            lightboxState.pinch = null;
            if (lightboxState.zoom < 1.1) resetLightboxZoom();
          }

          if (event.touches.length === 0 && lightboxState.touchStart) {
            const start = lightboxState.touchStart;
            const changedTouch = event.changedTouches[0];
            const now = Date.now();
            const dx = changedTouch.clientX - start.x;
            const dy = changedTouch.clientY - start.y;
            const moved = Math.abs(dx) > 15 || Math.abs(dy) > 15;
            const elapsed = now - start.time;

            if (!moved && elapsed < 300) {
              const sinceLastTap = now - lightboxState.lastTapAt;
              if (sinceLastTap < 350) {
                if (lightboxState.zoom > 1) {
                  resetLightboxZoom();
                } else {
                  const zoomLevel = LIGHTBOX_MOBILE_MAX_ZOOM;
                  const rect = getLightboxInteractionRect() || lightboxViewport.getBoundingClientRect();
                  const relX = (changedTouch.clientX - rect.left) / rect.width;
                  const relY = (changedTouch.clientY - rect.top) / rect.height;
                  const max = getLightboxMaxTranslate(zoomLevel);
                  lightboxState.zoom = zoomLevel;
                  lightboxState.translate = clampLightboxTranslate(
                    (0.5 - relX) * 2 * max.x,
                    (0.5 - relY) * 2 * max.y,
                    zoomLevel
                  );
                  applyLightboxTransform();
                }
                lightboxState.lastTapAt = 0;
              } else {
                lightboxState.lastTapAt = now;
              }
            }

            if (
              lightboxState.zoom <= 1 &&
              Math.abs(dx) > 60 &&
              Math.abs(dx) > Math.abs(dy) &&
              elapsed < 400
            ) {
              navigateLightbox(dx < 0 ? 1 : -1);
            }
          }

          lightboxState.touchStart = null;
          lightboxState.pan = null;
        },
        { passive: true }
      );
    }

    lightboxCloseButton?.addEventListener('click', () => closeLightbox());
    lightboxPrevButton?.addEventListener('click', () => navigateLightbox(-1));
    lightboxNextButton?.addEventListener('click', () => navigateLightbox(1));
    window.addEventListener('popstate', handleLightboxPopState);
    window.addEventListener('keydown', handleLightboxKeydown);

    const updateGalleryForVariant = (variant) => {
      if (!variant) return;
      const color = getSelectedColorForVariant(variant);
      const { visible, colorMedia } = getVisibleMediaForColor(color);
      const visibleItems = buildVisibleItems(visible);
      if (!visibleItems.length) {
        clearStageFadeTimer();
        clearMobileFadeTimer();
        setMobileTrackFade(true);
        if (lightboxState.open) closeLightbox();
        return;
      }
      clearMobileFadeTimer();

      const nextVisibleItemsKey = buildVisibleItemsKey(visibleItems);
      const itemsChanged =
        state.initialized && state.visibleItemsKey !== '' && state.visibleItemsKey !== nextVisibleItemsKey;
      const variantCrossfade = itemsChanged && state.initialized;
      const wasOnShared = state.initialized && taggingEnabled && state.activeKind === 'shared';
      const wasOnProof = state.initialized && state.activeKind === 'proof';
      const currentActiveItem = state.visibleItems[state.activeIndex];
      const currentActiveMediaId = currentActiveItem?.type === 'media' ? String(currentActiveItem.id) : null;
      const currentActiveIsShared =
        currentActiveItem?.type === 'media' &&
        taggingEnabled &&
        (() => {
          const activeAlt = getMediaAltRaw(currentActiveItem.media);
          const { shared, colorTag } = parseAlt(activeAlt);
          return shared || !colorTag;
        })();

      state.colorMediaLength = colorMedia.length;

      const selectAndRefresh = (indexToSelect, selectOptions = {}) => {
        selectMediaIndex(indexToSelect, visibleItems, {
          scrollMobile: false,
          instant: true,
          crossfade: selectOptions.crossfade === true,
        });
        refreshLightboxSlides();
      };

      const getVariantTargetIndex = () => {
        if (wasOnProof && proofId) {
          const proofIndex = visibleItems.findIndex((item) => item.type === 'proof');
          if (proofIndex >= 0) return proofIndex;
        }

        if (wasOnShared || currentActiveIsShared) {
          if (colorMedia.length) return 0;
          if (currentActiveMediaId) {
            const sameSharedMediaIndex = visibleItems.findIndex(
              (item) => item.type === 'media' && item.id === currentActiveMediaId
            );
            if (sameSharedMediaIndex >= 0) return sameSharedMediaIndex;
          }
          return 0;
        }

        if (colorMedia.length) {
          return Math.min(state.activeIndex, colorMedia.length - 1);
        }

        return 0;
      };

      const selectForVariantChange = (indexToSelect) =>
        selectAndRefresh(indexToSelect, { crossfade: variantCrossfade });

      const syncMobileViewportToIndex = (indexToSelect, behavior = 'auto') => {
        if (!mobileTrack) return;
        const safeIndex = Math.max(0, Math.min(indexToSelect, visibleItems.length - 1));
        const targetItem = visibleItems[safeIndex];
        if (!targetItem) return;
        scrollMobileToItem(targetItem.id, behavior);
      };

      if (!state.initialized) {
        state.initialized = true;
        applyGalleryOrderAndVisibility(visibleItems);
        state.visibleItemsKey = nextVisibleItemsKey;

        const featuredMediaId =
          variant?.featured_media && typeof variant.featured_media === 'object' ? variant.featured_media.id : variant?.featured_media;
        const initialFeaturedIndex = featuredMediaId
          ? visibleItems.findIndex((item) => item.type === 'media' && String(item?.media?.id) === String(featuredMediaId))
          : -1;

        selectAndRefresh(initialFeaturedIndex >= 0 ? initialFeaturedIndex : 0);
        setMobileTrackFade(true);
        return;
      }

      const targetIndex = getVariantTargetIndex();
      const isMobileViewport = !!mobileTrack && window.matchMedia('(max-width: 749px)').matches;
      const shouldSequenceMobileSwap =
        variantCrossfade && !prefersReducedMotion && isMobileViewport;

      if (shouldSequenceMobileSwap) {
        setMobileTrackFade(false);
        mobileFadeTimer = window.setTimeout(() => {
          applyGalleryOrderAndVisibility(visibleItems);
          state.visibleItemsKey = nextVisibleItemsKey;
          selectForVariantChange(targetIndex);
          syncMobileViewportToIndex(targetIndex, 'auto');
          setMobileTrackFade(true);
          mobileFadeTimer = null;
        }, STAGE_CROSSFADE_MS);
        return;
      }

      setMobileTrackFade(true);
      applyGalleryOrderAndVisibility(visibleItems);
      state.visibleItemsKey = nextVisibleItemsKey;
      selectForVariantChange(targetIndex);
      if (isMobileViewport && itemsChanged) {
        syncMobileViewportToIndex(targetIndex, 'auto');
      }
    };

    const formatCurrency = (cents, { minimumFractionDigits = 0, maximumFractionDigits = 2 } = {}) => {
      try {
        return new Intl.NumberFormat('pl-PL', {
          style: 'currency',
          currency: 'PLN',
          minimumFractionDigits,
          maximumFractionDigits,
        })
          .format(cents / 100)
          .replace(/\u00a0/g, ' ');
      } catch (error) {
        const value = (cents / 100).toFixed(Math.max(minimumFractionDigits, 2)).replace('.', ',');
        return `${value} zÅ‚`;
      }
    };

    const clearStickyLoadingTimer = () => {
      if (!stickyLoadingTimer) return;
      window.clearTimeout(stickyLoadingTimer);
      stickyLoadingTimer = null;
    };

    const setButtonLoadingState = (button, isLoading, options = {}) => {
      if (!(button instanceof HTMLElement)) return;
      const disableControl = options.disableControl !== false;

      const spinner = button.querySelector('.loading__spinner');
      button.classList.toggle('loading', isLoading);

      if (isLoading) {
        button.setAttribute('aria-busy', 'true');
        if (disableControl) {
          button.setAttribute('aria-disabled', 'true');
          if ('disabled' in button) button.disabled = true;
        }
        if (spinner instanceof HTMLElement) spinner.classList.remove('hidden');
        return;
      }

      button.removeAttribute('aria-busy');
      if (disableControl) {
        button.removeAttribute('aria-disabled');
      }
      if (spinner instanceof HTMLElement) spinner.classList.add('hidden');
    };

    const syncStickyButtonsAvailability = () => {
      if (!stickyAtcButtons.length) return;

      const shouldDisable =
        !atcButton ||
        atcButton.disabled ||
        atcButton.getAttribute('aria-disabled') === 'true';

      stickyAtcButtons.forEach((stickyButton) => {
        if (!(stickyButton instanceof HTMLButtonElement)) return;
        if (stickyButton.classList.contains('loading')) return;
        stickyButton.disabled = shouldDisable;
        if (shouldDisable) stickyButton.setAttribute('aria-disabled', 'true');
        else stickyButton.removeAttribute('aria-disabled');
      });
    };

    const applyStickyLoadingState = (isLoading) => {
      if (!stickyAtcButtons.length) return;

      stickyAtcButtons.forEach((stickyButton) => {
        if (!(stickyButton instanceof HTMLButtonElement)) return;
        setButtonLoadingState(stickyButton, isLoading);
      });

      if (!isLoading) {
        syncStickyButtonsAvailability();
      }
    };

    const isStickyLoadingActive = () =>
      stickyAtcButtons.some((stickyButton) => stickyButton instanceof HTMLElement && stickyButton.classList.contains('loading'));

    const setStickyLoadingState = (isLoading, delayMs = 0) => {
      clearStickyLoadingTimer();

      if (!isLoading && delayMs > 0) {
        stickyLoadingTimer = window.setTimeout(() => {
          applyStickyLoadingState(false);
        }, delayMs);
        return;
      }

      applyStickyLoadingState(isLoading);
    };

    const setupStickyAvailabilityObserver = () => {
      if (!(atcButton instanceof HTMLElement)) return;
      if (typeof MutationObserver !== 'function') return;

      const observer = new MutationObserver(() => {
        if (isStickyLoadingActive()) return;
        syncStickyButtonsAvailability();
      });

      observer.observe(atcButton, {
        attributes: true,
        attributeFilter: ['disabled', 'aria-disabled', 'class'],
      });
    };

    setupStickyAvailabilityObserver();

    const getSelectedOptions = () => {
      const optionFieldsets = root.querySelectorAll('[data-lusena-option]');
      const values = [];
      optionFieldsets.forEach((fieldset) => {
        const input = fieldset.querySelector('input[type="radio"]:checked');
        values.push(input ? input.value : null);
      });
      return values;
    };

    const findVariant = (options) =>
      product?.variants?.find((v) => {
        if (!v?.options) return false;
        return v.options.every((opt, idx) => opt === options[idx]);
      });

    const setSelectedLabel = () => {
      const optionFieldsets = root.querySelectorAll('[data-lusena-option]');
      optionFieldsets.forEach((fieldset) => {
        const selected = fieldset.querySelector('input[type="radio"]:checked')?.value;
        const label = fieldset.querySelector('[data-lusena-selected]');
        if (label && selected) label.textContent = selected;
      });
    };

    const updateUIForVariant = (variant) => {
      if (!variant) return;
      if (variantIdInput) variantIdInput.value = variant.id;

      if (priceEl) priceEl.textContent = formatCurrency(variant.price, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
      stickyPrices.forEach((stickyPrice) => {
        stickyPrice.textContent = formatCurrency(variant.price, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
      });

      const perNightCents = Math.round(variant.price / 365);
      stickyPricePerNights.forEach((stickyPricePerNight) => {
        stickyPricePerNight.textContent = `${stickyPricePerNightPrefix}${formatCurrency(perNightCents, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        })}${stickyPricePerNightSuffix}`;
      });

      const stickyVariantLabel = getStickyVariantLabel(variant);
      stickyVariants.forEach((stickyVariant) => {
        stickyVariant.textContent = stickyVariantLabel;
      });

      const stickyImageSrc = getVariantImageSrc(variant);
      const normalizedStickyImageSrc = normalizeImageUrl(stickyImageSrc);
      if (stickyImages.length) {
        stickyImages.forEach((stickyImage) => {
          if (normalizedStickyImageSrc) {
            stickyImage.src = urlWithWidth(normalizedStickyImageSrc, 88) || normalizedStickyImageSrc;
          }

          if (stickyVariantLabel) stickyImage.alt = stickyVariantLabel;
          else if (product?.title) stickyImage.alt = product.title;
        });
      }

      const compareAt = variant.compare_at_price;
      if (compareAtEl) {
        if (compareAt && compareAt > variant.price) {
          compareAtEl.textContent = formatCurrency(compareAt, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
          compareAtEl.classList.remove('hidden');
        } else {
          compareAtEl.textContent = '';
          compareAtEl.classList.add('hidden');
        }
      }

      if (pricePerNightEl) {
        pricePerNightEl.textContent = `${pricePerNightPrefix}${formatCurrency(perNightCents, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}${pricePerNightSuffix}`;
      }

      const available = !!variant.available;
      if (stockText) {
        const inStock = stockText.dataset.inStock ?? '';
        const outOfStock = stockText.dataset.outOfStock ?? '';
        stockText.textContent = available ? inStock : outOfStock;
      }
      if (stockDot) {
        stockDot.classList.toggle('lusena-pdp__stock-dot--available', available);
        stockDot.classList.toggle('lusena-pdp__stock-dot--unavailable', !available);
      }
      if (atcButton) atcButton.disabled = !available;
      if (buyNowButton) {
        if (!buyNowButton.classList.contains('loading')) {
          buyNowButton.disabled = !available;
          if (available) buyNowButton.removeAttribute('aria-disabled');
        }
      }
      syncStickyButtonsAvailability();

      updateGalleryForVariant(variant);
    };

    root.addEventListener('change', (e) => {
      const target = e.target;
      if (!(target instanceof HTMLInputElement)) return;
      if (target.type !== 'radio') return;

      setSelectedLabel();

      const options = getSelectedOptions();
      const variant = findVariant(options);
      updateUIForVariant(variant);
    });

    if (addToCartFormEl) {
      addToCartFormEl.addEventListener('submit', () => {
        if (!atcButton || atcButton.disabled || atcButton.getAttribute('aria-disabled') === 'true') return;
        stickyLoadingStartedAt = window.performance?.now ? window.performance.now() : Date.now();
        setStickyLoadingState(true);
      });
    }

    if (typeof subscribe === 'function' && typeof PUB_SUB_EVENTS !== 'undefined') {
      subscribe(PUB_SUB_EVENTS.cartUpdate, (event) => {
        if (!event || event.source !== 'product-form') return;
        if (!isStickyLoadingActive() && stickyLoadingStartedAt === null) return;

        let releaseDelay = addToCartLoadingHoldMs;
        if (stickyLoadingStartedAt !== null) {
          const now = window.performance?.now ? window.performance.now() : Date.now();
          const elapsed = Math.max(0, now - stickyLoadingStartedAt);
          const remainingMinDelay = Math.max(0, addToCartLoadingMinMs - elapsed);
          releaseDelay = remainingMinDelay + addToCartLoadingHoldMs;
        }

        stickyLoadingStartedAt = null;
        setStickyLoadingState(false, releaseDelay);
      });

      subscribe(PUB_SUB_EVENTS.cartError, (event) => {
        if (!event || event.source !== 'product-form') return;
        if (!isStickyLoadingActive() && stickyLoadingStartedAt === null) return;
        stickyLoadingStartedAt = null;
        setStickyLoadingState(false);
      });
    }

    if (buyNowButton && atcButton) {
      buyNowButton.addEventListener('click', async (event) => {
        event.preventDefault();
        event.stopPropagation();

        if (atcButton.disabled) return;
        if (buyNowButton.classList.contains('loading')) return;

        const variantId = variantIdInput?.value;
        const checkoutUrl = window.routes?.checkout_url || '/checkout';
        if (!variantId || typeof fetchConfig !== 'function' || !window.routes?.cart_add_url) {
          return;
        }

        const buyNowLoadingStartedAt = window.performance?.now ? window.performance.now() : Date.now();
        let redirectedToCheckout = false;
        setButtonLoadingState(buyNowButton, true, { disableControl: false });

        try {
          const formData = addToCartFormEl ? new FormData(addToCartFormEl) : new FormData();
          formData.set('id', variantId);
          if (!formData.has('quantity')) {
            formData.set('quantity', '1');
          }

          const config = fetchConfig('javascript');
          config.headers['X-Requested-With'] = 'XMLHttpRequest';
          delete config.headers['Content-Type'];
          config.body = formData;

          const response = await fetch(window.routes.cart_add_url, config);
          const data = await response.json();

          if (!response.ok || data?.status) {
            return;
          }

          const buyNowLoadingEndedAt = window.performance?.now ? window.performance.now() : Date.now();
          const elapsed = Math.max(0, buyNowLoadingEndedAt - buyNowLoadingStartedAt);
          const remainingMinDelay = Math.max(0, BUY_NOW_LOADING_MIN_MS - elapsed);
          const totalDelay = remainingMinDelay + BUY_NOW_LOADING_HOLD_MS;

          if (totalDelay > 0) {
            await wait(totalDelay);
          }

          redirectedToCheckout = true;
          window.location.href = checkoutUrl;
        } catch (error) {
          console.error(error);
        } finally {
          if (redirectedToCheckout) return;
          setButtonLoadingState(buyNowButton, false, { disableControl: false });
          buyNowButton.removeAttribute('aria-disabled');
          buyNowButton.disabled = atcButton.disabled;
          if (buyNowButton.disabled) buyNowButton.setAttribute('aria-disabled', 'true');
        }
      });
    }

    const getAccordionItemParts = (item) => {
      if (!(item instanceof HTMLElement)) return { trigger: null, content: null };
      return {
        trigger: item.querySelector('[data-lusena-accordion-trigger]'),
        content: item.querySelector('[data-lusena-accordion-content]'),
      };
    };

    const setAccordionContentState = (content, isOpen) => {
      if (!(content instanceof HTMLElement)) return;
      const inner = content.firstElementChild instanceof HTMLElement ? content.firstElementChild : content;
      if (typeof content._lusenaAccordionOnEnd === 'function') {
        content.removeEventListener('transitionend', content._lusenaAccordionOnEnd);
        content._lusenaAccordionOnEnd = null;
      }

      if (prefersReducedMotion) {
        content.dataset.state = isOpen ? 'open' : 'closed';
        content.style.height = isOpen ? 'auto' : '0px';
        return;
      }

      if (isOpen) {
        content.style.height = '0px';
        content.dataset.state = 'open';
        const h = inner.scrollHeight;
        requestAnimationFrame(() => {
          content.style.height = h + 'px';
        });
        const onEnd = (e) => {
          if (e.target !== content || e.propertyName !== 'height') return;
          content.removeEventListener('transitionend', onEnd);
          content._lusenaAccordionOnEnd = null;
          content.style.height = 'auto';
        };
        content._lusenaAccordionOnEnd = onEnd;
        content.addEventListener('transitionend', onEnd);
      } else {
        const h = content.offsetHeight;
        content.style.height = h + 'px';
        content.dataset.state = 'closed';
        requestAnimationFrame(() => {
          content.style.height = '0px';
        });
      }
    };

    const setAccordionItemState = (item, isOpen) => {
      if (!(item instanceof HTMLElement)) return;

      const { trigger, content } = getAccordionItemParts(item);
      const state = isOpen ? 'open' : 'closed';

      item.dataset.state = state;

      if (trigger instanceof HTMLElement) {
        trigger.dataset.state = state;
        trigger.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      }

      if (content instanceof HTMLElement) {
        setAccordionContentState(content, isOpen);
      }
    };

    const closeSiblingAccordionItems = (accordionRoot, currentItem) => {
      if (!(accordionRoot instanceof HTMLElement)) return;
      const items = Array.from(accordionRoot.querySelectorAll('[data-lusena-accordion-item]'));
      items.forEach((item) => {
        if (!(item instanceof HTMLElement) || item === currentItem) return;
        setAccordionItemState(item, false);
      });
    };

    const onFastTap = (el, callback) => {
      let startX, startY, handled;
      el.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        handled = false;
      }, { passive: true });
      el.addEventListener('touchend', (e) => {
        const t = e.changedTouches[0];
        if (Math.abs(t.clientX - startX) < 10 && Math.abs(t.clientY - startY) < 10) {
          handled = true;
          e.preventDefault();
          callback(e);
        }
      }, { passive: false });
      el.addEventListener('click', (e) => {
        if (!handled) callback(e);
        handled = false;
      });
    };

    const initializeAccordionRoot = (accordionRoot) => {
      if (!(accordionRoot instanceof HTMLElement)) return;

      const isSingle = accordionRoot.hasAttribute('data-lusena-accordion-single');
      const isCollapsible = accordionRoot.hasAttribute('data-lusena-accordion-collapsible');
      const items = Array.from(accordionRoot.querySelectorAll('[data-lusena-accordion-item]'));

      items.forEach((item) => {
        if (!(item instanceof HTMLElement)) return;
        setAccordionItemState(item, false);

        const { trigger } = getAccordionItemParts(item);
        if (!(trigger instanceof HTMLButtonElement)) return;

        onFastTap(trigger, () => {
          const currentlyOpen = item.dataset.state === 'open';

          if (currentlyOpen && isCollapsible) {
            setAccordionItemState(item, false);
            return;
          }

          if (isSingle) {
            closeSiblingAccordionItems(accordionRoot, item);
          }

          setAccordionItemState(item, true);
        });
      });
    };

    if (accordionRoots.length) {
      accordionRoots.forEach((accordionRoot) => {
        initializeAccordionRoot(accordionRoot);
      });
    }

    if (specDefinitionToggles.length) {
      specDefinitionToggles.forEach((toggleButton) => {
        if (!(toggleButton instanceof HTMLButtonElement)) return;

        toggleButton.addEventListener('click', () => {
          const specsTable = toggleButton.closest('[data-lusena-specs-table]');
          const key = toggleButton.dataset.specKey;
          if (!(specsTable instanceof HTMLElement) || !key) return;

          const definitionRow = specsTable.querySelector(
            `[data-lusena-spec-def-row][data-spec-key="${key}"]`
          );
          if (!(definitionRow instanceof HTMLElement)) return;

          const isOpen = !definitionRow.hidden;

          const rows = Array.from(specsTable.querySelectorAll('[data-lusena-spec-def-row]'));
          const buttons = Array.from(specsTable.querySelectorAll('[data-lusena-spec-def-toggle]'));

          rows.forEach((row) => {
            if (row instanceof HTMLElement) row.hidden = true;
          });

          buttons.forEach((button) => {
            if (button instanceof HTMLElement) {
              button.setAttribute('aria-expanded', 'false');
            }
          });

          if (!isOpen) {
            definitionRow.hidden = false;
            toggleButton.setAttribute('aria-expanded', 'true');
          }

        });
      });
    }

    const openReturnsAccordion = () => {
      const detailsSection = document.getElementById('details');
      const returnsAccordion =
        detailsSection?.querySelector('[data-lusena-accordion-returns]') ||
        root.querySelector('[data-lusena-accordion-returns]') ||
        document.querySelector('[data-lusena-accordion-returns]');

      if (returnsAccordion instanceof HTMLElement) {
        if (returnsAccordion instanceof HTMLDetailsElement) {
          returnsAccordion.open = true;
        } else {
          const returnsRoot = returnsAccordion.closest('[data-lusena-accordion-root]');
          if (returnsRoot instanceof HTMLElement && returnsRoot.hasAttribute('data-lusena-accordion-single')) {
            closeSiblingAccordionItems(returnsRoot, returnsAccordion);
          }
          setAccordionItemState(returnsAccordion, true);
        }
      }

      if (detailsSection) {
        detailsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    };

    if (returnsLinks.length) {
      returnsLinks.forEach((link) => {
        link.addEventListener('click', (event) => {
          event.preventDefault();
          openReturnsAccordion();
        });
      });
    }

    const openLightboxFromActiveStage = () => {
      if (!state.visibleItems.length) return;
      const activeItem = state.visibleItems[state.activeIndex];
      if (!activeItem || activeItem.type !== 'media' || !isMediaZoomable(activeItem.media)) return;
      openLightboxByItemId(activeItem.id);
    };

    if (stageAction) {
      stageAction.addEventListener('click', (event) => {
        if (event.target instanceof HTMLElement && event.target.closest('a')) return;
        if (stageAction.dataset.lusenaStageZoomable !== 'true') return;
        openLightboxFromActiveStage();
      });

      stageAction.addEventListener('keydown', (event) => {
        if (stageAction.dataset.lusenaStageZoomable !== 'true') return;
        if (event.key !== 'Enter' && event.key !== ' ') return;
        event.preventDefault();
        openLightboxFromActiveStage();
      });
    }

    if (thumbEls.length) {
      thumbEls.forEach((el) => {
        el.addEventListener('click', () => {
          const id = el?.dataset?.mediaId ? String(el.dataset.mediaId) : null;
          if (!id) return;
          const idx = state.visibleItems.findIndex((item) => item.id === id);
          if (idx < 0) return;
          if (idx === state.activeIndex) return;
          selectMediaIndex(idx, state.visibleItems, { instant: true, crossfade: true });
        });
      });
    }

    if (mobileDotEls.length) {
      mobileDotEls.forEach((dot) => {
        dot.addEventListener('click', () => {
          const id = dot?.dataset?.mediaId ? String(dot.dataset.mediaId) : null;
          if (!id) return;
          const idx = state.visibleItems.findIndex((item) => item.id === id);
          if (idx < 0) return;
          selectMediaIndex(idx, state.visibleItems);
        });
      });
    }

    if (mobileSlideEls.length) {
      mobileSlideEls.forEach((slide) => {
        slide.addEventListener('click', (event) => {
          if (event.target instanceof HTMLElement && event.target.closest('a')) return;
          const id = slide?.dataset?.mediaId ? String(slide.dataset.mediaId) : null;
          if (!id) return;
          const idx = state.visibleItems.findIndex((item) => item.id === id);
          if (idx < 0) return;
          selectMediaIndex(idx, state.visibleItems, { instant: true });
          if (slide.hasAttribute('data-lusena-mobile-zoomable')) {
            openLightboxByItemId(id);
          }
        });
      });
    }

    if (mobileTrack) {
      let scrollFrame = null;
      mobileTrack.addEventListener(
        'scroll',
        () => {
          if (scrollFrame) return;
          scrollFrame = window.requestAnimationFrame(() => {
            scrollFrame = null;
            if (!state.visibleItems.length) return;
            const visibleSlides = state.visibleItems
              .map((item) => slidesById.get(item.id))
              .filter((slide) => slide && !slide.hidden);
            if (!visibleSlides.length) return;

            let closestIndex = 0;
            let closestDistance = Number.POSITIVE_INFINITY;
            const scrollLeft = mobileTrack.scrollLeft;

            visibleSlides.forEach((slide, index) => {
              const distance = Math.abs(slide.offsetLeft - scrollLeft);
              if (distance < closestDistance) {
                closestDistance = distance;
                closestIndex = index;
              }
            });

            if (closestIndex !== state.activeIndex) {
              selectMediaIndex(closestIndex, state.visibleItems, { scrollMobile: false, instant: true });
            }
          });
        },
        { passive: true }
      );
    }

    setSelectedLabel();
    updateUIForVariant(
      findVariant(getSelectedOptions()) ||
        product?.variants?.find((v) => String(v.id) === String(variantIdInput?.value || '')) ||
        product?.variants?.[0]
    );

    const mainCta = root.querySelector('#main-cta');
    if (!stickyBar || !mainCta) return;

    const show = () => stickyBar.classList.remove('translate-y-full');
    const hide = () => stickyBar.classList.add('translate-y-full');
    const hasPassedMainCta = () => {
      const rect = mainCta.getBoundingClientRect();
      return rect.bottom <= 0;
    };
    const syncStickyVisibility = () => {
      if (hasPassedMainCta()) show();
      else hide();
    };

    hide();

    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              hide();
              return;
            }

            if (entry.boundingClientRect.bottom <= 0) show();
            else hide();
          });
        },
        { threshold: 0 }
      );
      io.observe(mainCta);
      syncStickyVisibility();
      return;
    }

    const onScroll = () => {
      syncStickyVisibility();
    };
    onScroll();
    window.addEventListener('scroll', onScroll, { passive: true });
  })();
{% endjavascript %}
